<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8" />
    <title>Minecraft JSON Generator ‚Äì 1.21+ Recipes & Tags</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <style>
        :root {
            --bg: #050816;
            --bg-elevated: #0b1020;
            --bg-elevated-soft: #0e1224;
            --accent: #4ade80;
            --accent-soft: rgba(74, 222, 128, 0.18);
            --accent-strong: #22c55e;
            --text: #f9fafb;
            --muted: #9ca3af;
            --border-subtle: rgba(148, 163, 184, 0.25);
            --danger: #fb7185;
            --radius-xl: 18px;
            --shadow-soft: 0 18px 40px rgba(15, 23, 42, 0.65);
            --shadow-subtle: 0 10px 30px rgba(15, 23, 42, 0.4);
            --slot-border: rgba(148, 163, 184, 0.3);
            --slot-bg: rgba(15, 23, 42, 0.7);
            --chip-bg: rgba(15, 23, 42, 0.85);
            --chip-selected: #020617;
        }

        * {
            box-sizing: border-box;
        }

        body {
            margin: 0;
            font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
            background: radial-gradient(circle at top, #111827 0, #020617 55%, #020617 100%);
            color: var(--text);
            min-height: 100vh;
            display: flex;
            align-items: stretch;
            justify-content: center;
        }

        .app {
            max-width: 1400px;
            width: 100%;
            margin: 20px;
            padding: 18px 18px 24px;
            border-radius: 24px;
            background: radial-gradient(circle at top left, rgba(56, 189, 248, 0.28), transparent 45%),
                radial-gradient(circle at bottom right, rgba(45, 212, 191, 0.3), transparent 50%),
                linear-gradient(145deg, rgba(15, 23, 42, 0.97), #020617);
            box-shadow: var(--shadow-soft);
            border: 1px solid rgba(148, 163, 184, 0.35);
            display: flex;
            flex-direction: column;
            gap: 18px;
        }

        header {
            display: flex;
            flex-wrap: wrap;
            justify-content: space-between;
            gap: 16px;
            align-items: center;
        }

        header .title-section {
            display: flex;
            align-items: center;
            gap: 14px;
        }

        .logo-pill {
            width: 44px;
            height: 44px;
            border-radius: 16px;
            background: radial-gradient(circle at 30% 20%, #facc15, #f97316 40%, #0f172a 80%);
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: 0 0 0 1px rgba(15, 23, 42, 0.9),
                0 10px 30px rgba(15, 23, 42, 0.9);
            font-size: 22px;
        }

        header h1 {
            margin: 0;
            font-size: 1.4rem;
            letter-spacing: 0.03em;
            display: flex;
            flex-direction: column;
            gap: 3px;
        }

        header h1 span {
            font-size: 0.8rem;
            font-weight: 400;
            color: var(--muted);
        }

        .badge-row {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
            font-size: 0.78rem;
        }

        .badge {
            padding: 4px 9px;
            border-radius: 999px;
            border: 1px solid rgba(148, 163, 184, 0.4);
            background: rgba(15, 23, 42, 0.85);
            display: inline-flex;
            gap: 6px;
            align-items: center;
            color: var(--muted);
        }

        .badge strong {
            color: var(--accent);
            font-weight: 600;
        }

        .tab-bar {
            margin-top: 4px;
            margin-bottom: 12px;
            padding: 4px;
            border-radius: 999px;
            background: rgba(15, 23, 42, 0.9);
            border: 1px solid var(--border-subtle);
            display: inline-flex;
            gap: 4px;
        }

        .tab-button {
            border: none;
            background: transparent;
            color: var(--muted);
            padding: 6px 11px;
            border-radius: 999px;
            cursor: pointer;
            display: flex;
            flex-direction: column;
            align-items: flex-start;
            gap: 2px;
            font-size: 0.8rem;
            transition: background 0.15s ease, color 0.15s ease,
                box-shadow 0.15s ease, transform 0.06s ease;
        }

        .tab-button.active {
            background: radial-gradient(circle at top, rgba(74, 222, 128, 0.18), transparent 60%);
            color: var(--text);
            box-shadow: 0 12px 30px rgba(15, 23, 42, 0.9);
            transform: translateY(-0.5px);
        }

        .tab-label-main {
            font-weight: 600;
            font-size: 0.82rem;
        }

        .tab-label-sub {
            font-size: 0.72rem;
        }

        .tab-panel {
            margin-top: 6px;
        }

        .layout {
            display: grid;
            grid-template-columns: minmax(0, 1.05fr) minmax(0, 1.1fr) minmax(0, 0.9fr);
            gap: 16px;
        }

        .layout-tags {
            display: grid;
            grid-template-columns: minmax(0, 1.2fr) minmax(0, 1fr);
            gap: 16px;
        }

        @media (max-width: 1100px) {
            .layout {
                grid-template-columns: minmax(0, 1fr);
            }

            .layout-tags {
                grid-template-columns: minmax(0, 1fr);
            }
        }

        .panel {
            background: radial-gradient(circle at top left, rgba(15, 23, 42, 0.9), rgba(15, 23, 42, 0.98));
            border-radius: var(--radius-xl);
            padding: 14px 14px 16px;
            border: 1px solid var(--border-subtle);
            box-shadow: var(--shadow-subtle);
            display: flex;
            flex-direction: column;
            gap: 12px;
            min-height: 0;
        }

        .panel-header {
            display: flex;
            justify-content: space-between;
            align-items: baseline;
            gap: 6px;
        }

        .panel-header h2 {
            margin: 0;
            font-size: 0.98rem;
            letter-spacing: 0.06em;
            text-transform: uppercase;
            color: #e5e7eb;
        }

        .panel-header span {
            font-size: 0.72rem;
            color: var(--muted);
        }

        .panel-body {
            display: flex;
            flex-direction: column;
            gap: 10px;
            font-size: 0.86rem;
        }

        .field {
            display: flex;
            flex-direction: column;
            gap: 4px;
        }

        .field-row {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
        }

        .field label {
            font-size: 0.78rem;
            text-transform: uppercase;
            letter-spacing: 0.09em;
            color: var(--muted);
        }

        .field small {
            color: var(--muted);
            font-size: 0.72rem;
        }

        input[type="text"],
        input[type="number"],
        select {
            width: 100%;
            padding: 7px 9px;
            border-radius: 999px;
            border: 1px solid rgba(148, 163, 184, 0.55);
            background: rgba(15, 23, 42, 0.9);
            color: var(--text);
            font-size: 0.86rem;
            outline: none;
            transition: border-color 0.15s ease, box-shadow 0.15s ease, background 0.15s ease;
        }

        input[type="text"]:focus,
        input[type="number"]:focus,
        select:focus {
            border-color: var(--accent);
            box-shadow: 0 0 0 1px rgba(74, 222, 128, 0.4);
            background: rgba(15, 23, 42, 0.96);
        }

        input[type="number"] {
            -moz-appearance: textfield;
        }

        input::-webkit-outer-spin-button,
        input::-webkit-inner-spin-button {
            -webkit-appearance: none;
            margin: 0;
        }

        .toggle-row {
            display: flex;
            align-items: center;
            gap: 7px;
            font-size: 0.8rem;
            color: var(--muted);
        }

        .toggle-row input[type="checkbox"] {
            width: 15px;
            height: 15px;
            accent-color: var(--accent);
        }

        .chip-row {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(150px, 1fr));
            gap: 6px;
        }

        .chip {
            border-radius: 999px;
            padding: 7px 10px;
            border: 1px solid rgba(148, 163, 184, 0.4);
            background: var(--chip-bg);
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 7px;
            cursor: pointer;
            font-size: 0.8rem;
            transition: background 0.15s ease, border-color 0.15s ease, transform 0.07s ease;
        }

        .chip-main {
            display: flex;
            align-items: center;
            gap: 7px;
        }

        .chip-icon {
            width: 20px;
            height: 20px;
            border-radius: 999px;
            background: rgba(15, 23, 42, 0.95);
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 0.88rem;
        }

        .chip-label {
            display: flex;
            flex-direction: column;
        }

        .chip-label strong {
            font-size: 0.82rem;
            color: var(--text);
            /* make main label white */
        }

        .chip-label span {
            color: var(--muted);
            font-size: 0.7rem;
        }

        .chip-meta {
            font-size: 0.66rem;
            text-transform: uppercase;
            letter-spacing: 0.08em;
            color: var(--muted);
        }

        .chip.selected {
            background: var(--chip-selected);
            border-color: var(--accent);
            box-shadow: 0 0 0 1px rgba(74, 222, 128, 0.4),
                0 10px 30px rgba(15, 23, 42, 0.9);
            transform: translateY(-1px);
        }

        .chip.selected .chip-icon {
            background: var(--accent-soft);
        }

        .chip.selected .chip-meta {
            color: var(--accent);
        }

        .recipe-divider {
            grid-column: 1 / -1;
            margin: 8px 2px 4px;
            padding: 4px 10px;
            font-size: 0.72rem;
            letter-spacing: 0.08em;
            text-transform: uppercase;
            color: var(--muted);
            border-bottom: 1px solid rgba(148, 163, 184, 0.35);
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .recipe-divider::before,
        .recipe-divider::after {
            content: "";
            flex: 1;
            height: 1px;
            background: linear-gradient(to right, transparent, rgba(148, 163, 184, 0.4));
        }

        .recipe-divider::after {
            background: linear-gradient(to left, transparent, rgba(148, 163, 184, 0.4));
        }

        .pill {
            padding: 3px 7px;
            border-radius: 999px;
            background: rgba(15, 23, 42, 0.95);
            border: 1px solid rgba(148, 163, 184, 0.4);
            font-size: 0.7rem;
            color: var(--muted);
            display: inline-flex;
            align-items: center;
            gap: 5px;
        }

        .pill-dot {
            width: 8px;
            height: 8px;
            border-radius: 999px;
            background: var(--accent);
            box-shadow: 0 0 0 4px rgba(74, 222, 128, 0.2);
        }

        /* Recipe editors */

        .type-editor {
            display: none;
            flex-direction: column;
            gap: 10px;
            padding: 10px;
            border-radius: 14px;
            background: linear-gradient(145deg, rgba(15, 23, 42, 0.95), rgba(15, 23, 42, 0.99));
            border: 1px solid rgba(148, 163, 184, 0.3);
        }

        .type-editor.active {
            display: flex;
        }

        .type-header {
            display: flex;
            justify-content: space-between;
            align-items: baseline;
            font-size: 0.84rem;
            gap: 6px;
        }

        .type-header strong {
            font-size: 0.88rem;
        }

        .type-header span {
            color: var(--muted);
            font-size: 0.75rem;
        }

        .hint {
            font-size: 0.75rem;
            color: var(--muted);
        }

        .editor-grid-wrapper {
            display: flex;
            flex-direction: row;
            gap: 16px;
            align-items: flex-start;
            flex-wrap: wrap;
        }

        .grid-card {
            padding: 8px;
            border-radius: 14px;
            border: 1px solid var(--slot-border);
            background: var(--bg-elevated-soft);
            display: inline-flex;
            flex-direction: column;
            gap: 6px;
        }

        .grid-title {
            font-size: 0.75rem;
            text-transform: uppercase;
            letter-spacing: 0.09em;
            color: var(--muted);
        }

        .craft-grid {
            display: grid;
            grid-template-columns: repeat(3, 44px);
            grid-template-rows: repeat(3, 44px);
            gap: 3px;
        }

        .craft-slot {
            width: 44px;
            height: 44px;
            border-radius: 12px;
            border: 1px solid var(--slot-border);
            background: var(--slot-bg);
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            font-size: 0.7rem;
            text-align: center;
            padding: 3px;
            color: var(--muted);
            transition: border-color 0.12s ease, box-shadow 0.12s ease, transform 0.06s ease, background 0.12s;
        }

        .craft-slot.selected {
            border-color: var(--accent);
            box-shadow: 0 0 0 1px rgba(74, 222, 128, 0.4);
            transform: translateY(-1px);
            background: linear-gradient(145deg, rgba(15, 23, 42, 0.95), rgba(22, 163, 74, 0.22));
            color: #e5e7eb;
        }

        .craft-slot span {
            display: block;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
            max-width: 100%;
        }

        .slot-caption {
            font-size: 0.7rem;
            color: var(--muted);
        }

        .slot-editor {
            min-width: 210px;
            max-width: 270px;
            display: flex;
            flex-direction: column;
            gap: 6px;
            padding: 8px 10px;
            border-radius: 14px;
            border: 1px dashed rgba(148, 163, 184, 0.6);
            background: radial-gradient(circle at top left, rgba(15, 23, 42, 0.95), rgba(15, 23, 42, 0.98));
        }

        .slot-editor-title {
            display: flex;
            justify-content: space-between;
            align-items: baseline;
            font-size: 0.78rem;
            color: var(--muted);
        }

        .ingredient-type-row {
            display: flex;
            gap: 6px;
            font-size: 0.75rem;
        }

        .ingredient-type-row label {
            display: flex;
            align-items: center;
            gap: 4px;
            cursor: pointer;
            text-transform: none;
            letter-spacing: 0;
            color: var(--muted);
        }

        .ingredient-type-row input[type="radio"] {
            accent-color: var(--accent);
        }

        .slot-editor .field {
            margin-top: 2px;
        }

        .slot-editor button {
            align-self: flex-start;
        }

        .ingredient-pill {
            font-size: 0.7rem;
            color: var(--muted);
        }

        .ingredient-pill code {
            color: #e5e7eb;
        }

        .furnace-layout {
            display: grid;
            grid-template-columns: minmax(0, 1fr) minmax(0, 1fr);
            gap: 10px;
        }

        @media (max-width: 850px) {
            .furnace-layout {
                grid-template-columns: minmax(0, 1fr);
            }
        }

        .furnace-layout .field {
            flex: 1;
        }

        .badge-note {
            font-size: 0.72rem;
            color: var(--muted);
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .badge-note span {
            padding: 2px 6px;
            border-radius: 999px;
            background: rgba(15, 23, 42, 0.95);
            border: 1px solid rgba(148, 163, 184, 0.4);
            font-size: 0.66rem;
            text-transform: uppercase;
            letter-spacing: 0.08em;
        }

        /* Tag values UI */

        .tag-values {
            display: flex;
            flex-direction: column;
            gap: 6px;
            margin-bottom: 6px;
        }

        .tag-value-row {
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .tag-value-kind {
            min-width: 125px;
        }

        .tag-value-input {
            flex: 1;
        }

        .tag-remove-btn {
            padding: 4px 7px;
            font-size: 0.72rem;
        }

        /* Output panel */

        .output-path {
            font-size: 0.78rem;
            color: var(--muted);
            display: flex;
            flex-direction: column;
            gap: 3px;
        }

        .output-path code {
            font-size: 0.78rem;
            color: #e5e7eb;
        }

        .output-actions {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
            margin-top: 4px;
        }

        .btn {
            border-radius: 999px;
            border: 1px solid rgba(148, 163, 184, 0.7);
            background: rgba(15, 23, 42, 0.95);
            color: var(--text);
            font-size: 0.82rem;
            padding: 6px 10px;
            display: inline-flex;
            align-items: center;
            gap: 6px;
            cursor: pointer;
            transition: background 0.15s, border-color 0.15s, transform 0.08s, box-shadow 0.12s;
        }

        .btn-primary {
            border-color: var(--accent-strong);
            background: linear-gradient(135deg, var(--accent-strong), #16a34a);
            color: #022c22;
            font-weight: 600;
            box-shadow: 0 10px 25px rgba(22, 163, 74, 0.45);
        }

        .btn-icon {
            font-size: 1rem;
            line-height: 1;
        }

        .btn:hover {
            transform: translateY(-1px);
            box-shadow: 0 10px 30px rgba(15, 23, 42, 0.7);
            background: rgba(15, 23, 42, 0.99);
        }

        .btn-primary:hover {
            background: linear-gradient(135deg, #22c55e, #16a34a);
        }

        .btn:active {
            transform: translateY(0);
            box-shadow: none;
        }

        .output-json-shell {
            flex: 1;
            min-height: 0;
            margin-top: 8px;
            border-radius: 14px;
            background: #020617;
            border: 1px solid rgba(15, 23, 42, 0.9);
            box-shadow: inset 0 0 0 1px rgba(15, 23, 42, 0.9);
            padding: 8px;
            display: flex;
            flex-direction: column;
            gap: 6px;
            position: relative;
            overflow: hidden;
        }

        .output-json-shell::before {
            content: "";
            position: absolute;
            inset: 0;
            background: radial-gradient(circle at top left, rgba(74, 222, 128, 0.08), transparent 50%);
            pointer-events: none;
        }

        .output-json {
            position: relative;
            z-index: 1;
            flex: 1;
            overflow: auto;
            padding: 8px;
            border-radius: 10px;
            background: #020617;
            font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
            font-size: 0.78rem;
            line-height: 1.4;
            color: #e5e7eb;
            white-space: pre;
        }

        .output-footer-note {
            font-size: 0.72rem;
            color: var(--muted);
            position: relative;
            z-index: 1;
        }

        .toast {
            position: fixed;
            bottom: 16px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(15, 23, 42, 0.98);
            color: var(--text);
            padding: 7px 11px;
            border-radius: 999px;
            font-size: 0.8rem;
            border: 1px solid rgba(148, 163, 184, 0.6);
            box-shadow: 0 18px 40px rgba(15, 23, 42, 0.9);
            display: none;
            align-items: center;
            gap: 8px;
            z-index: 9999;
        }

        .toast.show {
            display: inline-flex;
            animation: toastIn 0.2s ease-out;
        }

        @keyframes toastIn {
            from {
                opacity: 0;
                transform: translate(-50%, 5px);
            }

            to {
                opacity: 1;
                transform: translate(-50%, 0);
            }
        }

        .toast span {
            color: var(--accent);
        }

        .warning-text {
            font-size: 0.75rem;
            color: var(--danger);
        }

        .tiny {
            font-size: 0.7rem;
        }

        textarea {
            width: 100%;
            min-height: 90px;
            padding: 7px 9px;
            border-radius: 10px;
            border: 1px solid rgba(148, 163, 184, 0.55);
            background: rgba(15, 23, 42, 0.9);
            color: var(--text);
            font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
            font-size: 0.78rem;
            resize: vertical;
            outline: none;
        }

        textarea:focus {
            border-color: var(--accent);
            box-shadow: 0 0 0 1px rgba(74, 222, 128, 0.4);
            background: rgba(15, 23, 42, 0.96);
        }

        .code-textarea {
            white-space: pre;
        }

        .type-search {
            margin-bottom: 6px;
            font-size: 0.82rem;
        }
    </style>
</head>

<body>
    <div class="app">
        <header>
            <div class="title-section">
                <div class="logo-pill">‚õèÔ∏è</div>
                <div>
                    <h1>
                        Minecraft JSON Generator
                        <span>Minecraft 1.21+ JSON recipe &amp; tag generator</span>
                    </h1>
                    <div class="badge-row">
                        <div class="badge">
                            <strong>All vanilla types</strong>
                            <span>crafting, cooking, smithing, stonecutting, specials</span>
                        </div>
                        <div class="badge">
                            <span>Visual editor</span>
                            <span>3√ó3 grid, furnace &amp; smithing layouts</span>
                        </div>
                    </div>
                </div>
            </div>
            <div class="badge-row">
                <div class="pill">
                    <div class="pill-dot"></div>
                    <span>Java Edition 1.21+ (recipe/ &amp; tags/ folders)</span>
                </div>
            </div>
        </header>

        <main>
            <div class="tab-bar">
                <button class="tab-button active" data-tab="recipes">
                    <span class="tab-label-main">Recipes</span>
                    <span class="tab-label-sub">Recipe JSON generator</span>
                </button>
                <button class="tab-button" data-tab="tags">
                    <span class="tab-label-main">Tags</span>
                    <span class="tab-label-sub">Tag JSON generator</span>
                </button>
            </div>

            <!-- Recipes tab -->
            <div class="tab-panel layout" data-tab-panel="recipes">
                <!-- Left: Global settings + type chooser -->
                <section class="panel panel-settings">
                    <div class="panel-header">
                        <h2>Basics &amp; Result</h2>
                        <span>Namespace, file path, output stack</span>
                    </div>
                    <div class="panel-body">
                        <div class="field-row">
                            <div class="field" style="flex:1.1">
                                <label for="nsInput">Pack namespace</label>
                                <input id="nsInput" type="text" placeholder="mydatapack" value="mydatapack" />
                                <small>Used in <code>data/&lt;namespace&gt;/recipe/&lt;path&gt;.json</code></small>
                            </div>
                            <div class="field" style="flex:1.2">
                                <label for="pathInput">Recipe path (file name)</label>
                                <input id="pathInput" type="text" placeholder="my_cool_recipe" value="my_cool_recipe" />
                                <small>No <code>.json</code> ‚Äì folders allowed, e.g.
                                    <code>weapons/netherite_upgrade</code></small>
                            </div>
                        </div>

                        <div class="field-row">
                            <div class="field" style="flex:1.4">
                                <label for="resultItemInput">Result item ID</label>
                                <input id="resultItemInput" type="text" placeholder="minecraft:diamond_sword" />
                                <small>Required for most recipe types (ignored by smithing_trim, crafting_decorated_pot
                                    &amp; crafting_special_*)</small>
                            </div>
                            <div class="field" style="max-width:130px">
                                <label for="resultCountInput">Count</label>
                                <input id="resultCountInput" type="number" min="1" step="1" value="1" />
                                <small>Stack size (where supported)</small>
                            </div>
                        </div>

                        <div class="field-row">
                            <div class="field" style="flex:1">
                                <label for="groupInput">Recipe group (optional)</label>
                                <input id="groupInput" type="text" placeholder="my_group" />
                                <small>Groups recipes in the recipe book</small>
                            </div>
                            <div class="field" style="flex:1">
                                <label for="categorySelect">Category</label>
                                <select id="categorySelect">
                                    <option value="misc">misc</option>
                                    <option value="building">building</option>
                                    <option value="redstone">redstone</option>
                                    <option value="equipment">equipment</option>
                                    <option value="food">food</option>
                                    <option value="combat">combat</option>
                                    <option value="brewing">brewing</option>
                                    <option value="none">(omit field)</option>
                                </select>
                                <small>Recipe book tab (1.20+)</small>
                            </div>
                        </div>

                        <div class="toggle-row">
                            <input id="showNotificationToggle" type="checkbox" checked />
                            <label for="showNotificationToggle">Show recipe unlock toast (set
                                <code>show_notification</code> to false when off)</label>
                        </div>

                        <div class="field">
                            <label>Recipe type</label>
                            <input id="typeSearchInput" type="text"
                                placeholder="Search recipe types (e.g. ‚Äúsmelt‚Äù, ‚Äúcrushing‚Äù, ‚Äúcreate‚Äù)"
                                class="type-search" />
                            <div class="chip-row" id="typeChips"></div>
                        </div>
                </section>

                <!-- Middle: Editor per type -->
                <section class="panel panel-editor">
                    <div class="panel-header">
                        <h2>Recipe Editor</h2>
                        <span>Visual layout based on the selected recipe type</span>
                    </div>
                    <div class="panel-body" id="editors">
                        <!-- Crafting shaped -->
                        <div class="type-editor" data-editor="crafting_shaped">
                            <div class="type-header">
                                <strong>Shaped crafting ‚Äì 3√ó3 pattern</strong>
                                <span>Click a slot, then define an ingredient on the right</span>
                            </div>
                            <div class="editor-grid-wrapper">
                                <div class="grid-card">
                                    <div class="grid-title">Crafting grid (3√ó3)</div>
                                    <div class="craft-grid" id="shapedGrid"></div>
                                    <div class="slot-caption tiny">Empty rows/columns are trimmed automatically in the
                                        JSON pattern.</div>
                                </div>
                                <div class="slot-editor" id="shapedSlotEditor">
                                    <div class="slot-editor-title">
                                        <span>Selected slot</span>
                                        <span id="shapedSlotLabel" class="tiny">None selected</span>
                                    </div>
                                    <div class="ingredient-type-row">
                                        <label><input type="radio" name="shapedSlotKind" value="item" checked /> Item
                                            ID</label>
                                        <label><input type="radio" name="shapedSlotKind" value="tag" /> Tag</label>
                                    </div>
                                    <div class="field">
                                        <label for="shapedSlotValue">Item or tag</label>
                                        <input id="shapedSlotValue" type="text"
                                            placeholder="minecraft:iron_ingot or minecraft:logs" />
                                    </div>
                                    <button class="btn" type="button" id="shapedClearSlotBtn">
                                        <span class="btn-icon">üßπ</span> Clear slot
                                    </button>
                                    <div class="ingredient-pill tiny">
                                        Tip: use <code>minecraft:logs</code> with <b>Tag</b> for all log variants.
                                    </div>
                                </div>
                            </div>
                        </div>

                        <!-- Crafting shapeless -->
                        <div class="type-editor" data-editor="crafting_shapeless">
                            <div class="type-header">
                                <strong>Shapeless crafting ‚Äì up to 9 ingredients</strong>
                                <span>Order doesn‚Äôt matter</span>
                            </div>
                            <div class="editor-grid-wrapper">
                                <div class="grid-card">
                                    <div class="grid-title">Ingredient slots (max 9)</div>
                                    <div class="craft-grid" id="shapelessGrid"></div>
                                    <div class="slot-caption tiny">Use as many slots as needed; the JSON arranges them
                                        automatically.</div>
                                </div>
                                <div class="slot-editor" id="shapelessSlotEditor">
                                    <div class="slot-editor-title">
                                        <span>Selected ingredient</span>
                                        <span id="shapelessSlotLabel" class="tiny">None selected</span>
                                    </div>
                                    <div class="ingredient-type-row">
                                        <label><input type="radio" name="shapelessSlotKind" value="item" checked /> Item
                                            ID</label>
                                        <label><input type="radio" name="shapelessSlotKind" value="tag" /> Tag</label>
                                    </div>
                                    <div class="field">
                                        <label for="shapelessSlotValue">Item or tag</label>
                                        <input id="shapelessSlotValue" type="text"
                                            placeholder="minecraft:stick or minecraft:planks" />
                                    </div>
                                    <button class="btn" type="button" id="shapelessClearSlotBtn">
                                        <span class="btn-icon">üßπ</span> Clear slot
                                    </button>
                                    <div class="ingredient-pill tiny">
                                        Repeat the same ingredient in different slots to require multiples (e.g. 2
                                        sticks).
                                    </div>
                                </div>
                            </div>
                        </div>

                        <!-- Cooking: furnace / smoker / blast / campfire -->
                        <div class="type-editor" data-editor="cooking">
                            <div class="type-header">
                                <strong>Cooking recipes ‚Äì furnace, smoker, blast furnace, campfire</strong>
                                <span>Uses the same JSON layout for all four types</span>
                            </div>
                            <div class="furnace-layout">
                                <div class="field">
                                    <label>Input ingredient</label>
                                    <div class="ingredient-type-row">
                                        <label><input type="radio" name="cookKind" value="item" checked /> Item
                                            ID</label>
                                        <label><input type="radio" name="cookKind" value="tag" /> Tag</label>
                                    </div>
                                    <input id="cookValue" type="text"
                                        placeholder="minecraft:raw_iron or minecraft:ores" />
                                    <small class="hint">Will be placed in <code>ingredient</code> for smelting /
                                        blasting / smoking / campfire_cooking.</small>
                                </div>
                                <div class="field">
                                    <label>Cooking settings</label>
                                    <div class="field-row">
                                        <div class="field" style="flex:1">
                                            <label for="cookExpInput">Experience</label>
                                            <input id="cookExpInput" type="number" step="0.1" value="0.1" />
                                            <small class="tiny">Exp orbs granted (e.g. 0.1)</small>
                                        </div>
                                        <div class="field" style="flex:1">
                                            <label for="cookTimeInput">Cook time (ticks)</label>
                                            <input id="cookTimeInput" type="number" step="1" value="200" />
                                            <small class="tiny">Default furnace: 200, smoker/blast: 100, campfire:
                                                600</small>
                                        </div>
                                    </div>
                                    <div class="badge-note tiny">
                                        <span>Note</span>
                                        <div>Result item &amp; count are taken from the global fields above.</div>
                                    </div>
                                </div>
                            </div>
                        </div>

                        <!-- Farmer's Delight: Cooking Pot -->
                        <div class="type-editor" data-editor="fd_cooking">
                            <div class="type-header">
                                <strong>Farmer's Delight ‚Äì Cooking Pot</strong>
                                <span>Up to 6 ingredients, one result + optional container</span>
                            </div>

                            <div class="editor-grid-wrapper">
                                <div class="field" style="flex:1">
                                    <label>Ingredients</label>
                                    <div id="fdCookingIngredientsContainer" class="tag-values"></div>
                                    <button class="btn" type="button" id="addFdCookingIngredientBtn">
                                        <span class="btn-icon">‚ûï</span> Add ingredient
                                    </button>
                                    <small class="tiny">
                                        Each entry becomes a standard ingredient object
                                        (<code>{"item": "..."}</code> or <code>{"tag": "..."}</code>) in the
                                        <code>ingredients</code> array.
                                    </small>
                                </div>

                                <div class="field" style="flex:1">
                                    <label>Cooking settings</label>

                                    <div class="field-row">
                                        <div class="field" style="flex:1">
                                            <label for="fdCookingTimeInput">Cooking time (ticks)</label>
                                            <input id="fdCookingTimeInput" type="number" min="0" step="1" value="200" />
                                            <small class="tiny">
                                                Writes <code>cookingtime</code> (defaults to 200 if omitted).
                                            </small>
                                        </div>
                                        <div class="field" style="flex:1">
                                            <label for="fdCookingExpInput">Experience</label>
                                            <input id="fdCookingExpInput" type="number" step="0.1" value="0" />
                                            <small class="tiny">
                                                Optional <code>experience</code> field.
                                            </small>
                                        </div>
                                    </div>

                                    <div class="field-row">
                                        <div class="field" style="flex:1">
                                            <label for="fdCookingContainerInput">Container item (optional)</label>
                                            <input id="fdCookingContainerInput" type="text"
                                                placeholder="minecraft:bowl" />
                                            <small class="tiny">
                                                Written as <code>{"container": {"item": "..."}}</code>.
                                            </small>
                                        </div>
                                        <div class="field" style="flex:1">
                                            <label for="fdCookingTabSelect">Recipe book tab</label>
                                            <select id="fdCookingTabSelect">
                                                <option value="">(auto)</option>
                                                <option value="meals">meals</option>
                                                <option value="drinks">drinks</option>
                                                <option value="misc">misc</option>
                                            </select>
                                            <small class="tiny">
                                                Optional <code>recipe_book_tab</code> used by Farmer's Delight.
                                            </small>
                                        </div>
                                    </div>

                                    <div class="badge-note tiny">
                                        <span>Note</span>
                                        <div>
                                            The main result item &amp; count come from the global fields at the top;
                                            they are written to the <code>result</code> object here.
                                        </div>
                                    </div>
                                </div>
                            </div>
                        </div>

                        <!-- Farmer's Delight: Cutting Board -->
                        <div class="type-editor" data-editor="fd_cutting">
                            <div class="type-header">
                                <strong>Farmer's Delight ‚Äì Cutting Board</strong>
                                <span>Single input, tool + up to 4 results</span>
                            </div>

                            <div class="editor-grid-wrapper">
                                <div class="field" style="flex:1">
                                    <label>Input ingredient</label>
                                    <div id="fdCuttingIngredientContainer" class="tag-values"></div>
                                    <small class="tiny">
                                        FD uses a 1-element <code>ingredients</code> array for the item on the board.
                                    </small>
                                </div>

                                <div class="field" style="flex:1">
                                    <label>Tool</label>
                                    <div class="field">
                                        <div class="ingredient-type-row">
                                            <label>
                                                <input type="radio" name="fdToolMode" value="tag" checked />
                                                Tag (e.g. <code>forge:tools/knives</code>)
                                            </label>
                                            <label>
                                                <input type="radio" name="fdToolMode" value="item" />
                                                Item ID
                                            </label>
                                            <label>
                                                <input type="radio" name="fdToolMode" value="type" />
                                                Tool type
                                            </label>
                                        </div>
                                    </div>

                                    <div class="field">
                                        <label for="fdToolTagInput">Tool tag</label>
                                        <input id="fdToolTagInput" type="text" placeholder="forge:tools/knives" />
                                    </div>

                                    <div class="field">
                                        <label for="fdToolItemInput">Tool item ID</label>
                                        <input id="fdToolItemInput" type="text"
                                            placeholder="farmersdelight:iron_knife (optional)" />
                                    </div>

                                    <div class="field">
                                        <label for="fdToolTypeInput">Tool type (for farmersdelight:tool)</label>
                                        <input id="fdToolTypeInput" type="text" placeholder="axe, shovel, hoe..." />
                                        <small class="tiny">
                                            Builds <code>{"type": "farmersdelight:tool", "tool": "axe"}</code> when
                                            <b>Tool type</b> mode is selected.
                                        </small>
                                    </div>
                                </div>
                            </div>

                            <div class="field-row" style="margin-top:8px;">
                                <div class="field" style="flex:1">
                                    <label>Results (up to 4)</label>
                                    <div id="fdCuttingResultsContainer" class="tag-values"></div>
                                    <button class="btn" type="button" id="addFdCuttingResultBtn">
                                        <span class="btn-icon">‚ûï</span> Add result
                                    </button>
                                    <small class="tiny">
                                        Each result becomes <code>{"item": "...", "count": n?, "chance": 0‚Äì1?}</code>.
                                    </small>
                                </div>

                                <div class="field" style="max-width:220px">
                                    <label for="fdCuttingSoundInput">Custom sound (optional)</label>
                                    <input id="fdCuttingSoundInput" type="text"
                                        placeholder="minecraft:block.wood.break" />
                                    <small class="tiny">
                                        Written to <code>sound</code>, overriding the default cutting sound.
                                    </small>
                                </div>
                            </div>
                        </div>

                        <!-- Farmer's Delight: Decomposition (skeleton only) -->
                        <div class="type-editor" data-editor="fd_decomposition">
                            <div class="type-header">
                                <strong>Farmer's Delight ‚Äì Decomposition</strong>
                                <span>Skeleton recipe ‚Äì fill in JSON manually</span>
                            </div>
                            <div class="hint tiny">
                                The <code>farmersdelight:decomposition</code> recipe type is registered and used by JEI,
                                but its JSON layout is not documented the same way as cooking/cutting.
                                This generator will output a minimal recipe with the correct <code>type</code> and
                                common
                                fields so you can complete it by hand.
                            </div>
                        </div>

                        <!-- Stonecutting -->
                        <div class="type-editor" data-editor="stonecutting">
                            <div class="type-header">
                                <strong>Stonecutting</strong>
                                <span>One input to one (or more) outputs</span>
                            </div>
                            <div class="editor-grid-wrapper">
                                <div class="slot-editor">
                                    <div class="slot-editor-title">
                                        <span>Input block / tag</span>
                                    </div>
                                    <div class="ingredient-type-row">
                                        <label><input type="radio" name="stoneKind" value="item" checked /> Item
                                            ID</label>
                                        <label><input type="radio" name="stoneKind" value="tag" /> Tag</label>
                                    </div>
                                    <div class="field">
                                        <label for="stoneValue">Item or tag</label>
                                        <input id="stoneValue" type="text"
                                            placeholder="minecraft:stone or minecraft:stone_bricks" />
                                    </div>
                                </div>
                                <div class="slot-editor">
                                    <div class="slot-editor-title">
                                        <span>Output</span>
                                    </div>
                                    <div class="field">
                                        <label for="stoneCountInput">Output count</label>
                                        <input id="stoneCountInput" type="number" min="1" step="1" value="1" />
                                        <small class="tiny">Result item ID comes from global fields.</small>
                                    </div>
                                </div>
                            </div>
                        </div>

                        <!-- Smithing transform -->
                        <div class="type-editor" data-editor="smithing_transform">
                            <div class="type-header">
                                <strong>Smithing ‚Äì transform (upgrades)</strong>
                                <span>Template + base + addition ‚Üí new item</span>
                            </div>
                            <div class="editor-grid-wrapper">
                                <div class="slot-editor" style="flex:1">
                                    <div class="slot-editor-title">
                                        <span>Template</span>
                                        <span class="tiny">e.g.
                                            <code>minecraft:netherite_upgrade_smithing_template</code></span>
                                    </div>
                                    <div class="ingredient-type-row">
                                        <label><input type="radio" name="smithTemplateKind" value="item" checked /> Item
                                            ID</label>
                                        <label><input type="radio" name="smithTemplateKind" value="tag" /> Tag</label>
                                    </div>
                                    <input id="smithTemplateValue" type="text"
                                        placeholder="minecraft:netherite_upgrade_smithing_template" />
                                </div>
                                <div class="slot-editor" style="flex:1">
                                    <div class="slot-editor-title">
                                        <span>Base</span>
                                        <span class="tiny">The item to upgrade</span>
                                    </div>
                                    <div class="ingredient-type-row">
                                        <label><input type="radio" name="smithBaseKind" value="item" checked /> Item
                                            ID</label>
                                        <label><input type="radio" name="smithBaseKind" value="tag" /> Tag</label>
                                    </div>
                                    <input id="smithBaseValue" type="text" placeholder="minecraft:diamond_sword" />
                                </div>
                                <div class="slot-editor" style="flex:1">
                                    <div class="slot-editor-title">
                                        <span>Addition</span>
                                        <span class="tiny">The material</span>
                                    </div>
                                    <div class="ingredient-type-row">
                                        <label><input type="radio" name="smithAddKind" value="item" checked /> Item
                                            ID</label>
                                        <label><input type="radio" name="smithAddKind" value="tag" /> Tag</label>
                                    </div>
                                    <input id="smithAddValue" type="text" placeholder="minecraft:netherite_ingot" />
                                </div>
                            </div>
                            <div class="hint tiny">
                                Result item &amp; count are taken from the global fields (e.g.
                                <code>minecraft:netherite_sword</code> x1).
                            </div>
                        </div>

                        <!-- Smithing trim -->
                        <div class="type-editor" data-editor="smithing_trim">
                            <div class="type-header">
                                <strong>Smithing ‚Äì trim (armor trims)</strong>
                                <span>Template + armor + material ‚Üí trimmed armor</span>
                            </div>
                            <div class="editor-grid-wrapper">
                                <div class="slot-editor" style="flex:1">
                                    <div class="slot-editor-title">
                                        <span>Template</span>
                                    </div>
                                    <div class="ingredient-type-row">
                                        <label><input type="radio" name="trimTemplateKind" value="item" checked /> Item
                                            ID</label>
                                        <label><input type="radio" name="trimTemplateKind" value="tag" /> Tag</label>
                                    </div>
                                    <input id="trimTemplateValue" type="text"
                                        placeholder="minecraft:coast_armor_trim_smithing_template" />
                                </div>
                                <div class="slot-editor" style="flex:1">
                                    <div class="slot-editor-title">
                                        <span>Armor (base)</span>
                                    </div>
                                    <div class="ingredient-type-row">
                                        <label><input type="radio" name="trimBaseKind" value="item" checked /> Item
                                            ID</label>
                                        <label><input type="radio" name="trimBaseKind" value="tag" /> Tag</label>
                                    </div>
                                    <input id="trimBaseValue" type="text" placeholder="minecraft:diamond_chestplate" />
                                </div>
                                <div class="slot-editor" style="flex:1">
                                    <div class="slot-editor-title">
                                        <span>Material (addition)</span>
                                    </div>
                                    <div class="ingredient-type-row">
                                        <label><input type="radio" name="trimAddKind" value="item" checked /> Item
                                            ID</label>
                                        <label><input type="radio" name="trimAddKind" value="tag" /> Tag</label>
                                    </div>
                                    <input id="trimAddValue" type="text" placeholder="minecraft:redstone" />
                                </div>
                            </div>
                            <div class="warning-text tiny">
                                Trim recipes don‚Äôt specify a <code>result</code> stack ‚Äì the game copies and decorates
                                the base armor item.
                            </div>
                        </div>

                        <!-- Decorated pot -->
                        <div class="type-editor" data-editor="crafting_decorated_pot">
                            <div class="type-header">
                                <strong>Decorated pot ‚Äì special crafting serializer</strong>
                                <span>Vanilla 1.21+ type with minimal JSON</span>
                            </div>
                            <div class="hint tiny">
                                The vanilla decorated pot recipe uses a dedicated <code>crafting_decorated_pot</code>
                                serializer.
                                For 1.21+, the built-in recipe is effectively just:
                                <code>{"type": "minecraft:crafting_decorated_pot", "category": "misc"}</code>.
                                This editor will generate that minimal recipe plus your common fields.
                            </div>
                        </div>

                        <!-- Crafting specials -->
                        <div class="type-editor" data-editor="crafting_special">
                            <div class="type-header">
                                <strong>Special crafting recipes</strong>
                                <span>Handled by built-in logic</span>
                            </div>
                            <div class="field">
                                <label for="specialTypeSelect">Selected special serializer</label>
                                <select id="specialTypeSelect">
                                    <option value="minecraft:crafting_special_armordye">crafting_special_armordye ‚Äì dye
                                        leather armor</option>
                                    <option value="minecraft:crafting_special_bannerduplicate">
                                        crafting_special_bannerduplicate ‚Äì copy banner patterns</option>
                                    <option value="minecraft:crafting_special_bookcloning">crafting_special_bookcloning
                                        ‚Äì copy written books</option>
                                    <option value="minecraft:crafting_special_firework_rocket">
                                        crafting_special_firework_rocket ‚Äì fireworks</option>
                                    <option value="minecraft:crafting_special_firework_star">
                                        crafting_special_firework_star ‚Äì firework stars</option>
                                    <option value="minecraft:crafting_special_firework_star_fade">
                                        crafting_special_firework_star_fade ‚Äì add fades to stars</option>
                                    <option value="minecraft:crafting_special_mapcloning">crafting_special_mapcloning ‚Äì
                                        copy maps</option>
                                    <option value="minecraft:crafting_special_mapextending">
                                        crafting_special_mapextending ‚Äì zoom maps</option>
                                    <option value="minecraft:crafting_special_repairitem">crafting_special_repairitem ‚Äì
                                        tool repair</option>
                                    <option value="minecraft:crafting_special_shielddecoration">
                                        crafting_special_shielddecoration ‚Äì banner ‚Üí shield</option>
                                    <option value="minecraft:crafting_special_shulkerboxcoloring">
                                        crafting_special_shulkerboxcoloring ‚Äì recolor shulker boxes</option>
                                    <option value="minecraft:crafting_special_tippedarrow">crafting_special_tippedarrow
                                        ‚Äì tipped arrows</option>
                                    <option value="minecraft:crafting_special_suspiciousstew">
                                        crafting_special_suspiciousstew ‚Äì suspicious stew effects</option>
                                    <option value="minecraft:crafting_transmute">crafting_transmute ‚Äì experimental
                                        special serializer</option>
                                </select>
                                <small class="hint">
                                    Special recipes ignore pattern/ingredients in JSON ‚Äì the game implements the logic.
                                    Your output will simply be <code>{"type": "...", ...common fields}</code>.
                                </small>
                            </div>
                        </div>
                        <!-- Create: generic processing recipes -->
                        <div class="type-editor" data-editor="create_processing">
                            <div class="type-header">
                                <strong>Create ‚Äì processing recipes</strong>
                                <span id="createProcessingTypeLabel">Select a Create type chip (e.g. crushing, mixing,
                                    milling‚Ä¶)</span>
                            </div>

                            <div class="hint tiny">
                                Works for Create‚Äôs <code>compacting</code>, <code>crushing</code>, <code>cutting</code>,
                                <code>deploying</code>, <code>emptying</code>, <code>filling</code>,
                                <code>haunting</code>,
                                <code>item_application</code>, <code>milling</code>, <code>mixing</code>,
                                <code>pressing</code>,
                                <code>sandpaper_polishing</code> and <code>splashing</code> recipe types.
                                All of these share a simple <code>ingredients</code> + <code>results</code> JSON layout.
                                :contentReference[oaicite:1]{index=1}
                            </div>

                            <div class="field-row">
                                <div class="field" style="flex:1">
                                    <label>Ingredients</label>
                                    <div id="createIngredientsContainer" class="tag-values"></div>
                                    <button class="btn" type="button" id="addCreateIngredientBtn">
                                        <span class="btn-icon">‚ûï</span> Add ingredient
                                    </button>
                                    <small class="tiny">
                                        Use kind <b>Item</b> for <code>{"item": "mod:id", "count": n}</code>,
                                        <b>Tag</b> for <code>{"tag": "mod:tag"}</code>, and <b>Fluid</b> for
                                        <code>{"fluid": "mod:fluid", "amount": mB}</code>.
                                    </small>
                                </div>

                                <div class="field" style="flex:1">
                                    <label>Results</label>
                                    <div id="createResultsContainer" class="tag-values"></div>
                                    <button class="btn" type="button" id="addCreateResultBtn">
                                        <span class="btn-icon">‚ûï</span> Add result
                                    </button>
                                    <small class="tiny">
                                        For items, <code>count</code> is stack size. For fluids, <code>amount</code> is
                                        in millibuckets.
                                        Optional <b>chance</b> (0‚Äì1) is supported on result entries (e.g. crushing
                                        drops). :contentReference[oaicite:2]{index=2}
                                    </small>
                                </div>
                            </div>

                            <div class="field-row">
                                <div class="field" style="flex:1">
                                    <label for="createProcessingTimeInput">Processing time (ticks)</label>
                                    <input id="createProcessingTimeInput" type="number" min="0" step="1" value="100" />
                                    <small class="tiny">
                                        Used by <code>crushing</code>, <code>cutting</code>, and <code>milling</code>.
                                        Optional for others. :contentReference[oaicite:3]{index=3}
                                    </small>
                                </div>
                                <div class="field" style="flex:1">
                                    <label for="createHeatRequirementSelect">Heat requirement</label>
                                    <select id="createHeatRequirementSelect">
                                        <option value="">(none)</option>
                                        <option value="heated">heated</option>
                                        <option value="superheated">superheated</option>
                                    </select>
                                    <small class="tiny">
                                        Used by Create‚Äôs heated processes like
                                        <code>mixing</code>/<code>compacting</code>; leave empty otherwise.
                                        :contentReference[oaicite:4]{index=4}
                                    </small>
                                </div>
                            </div>
                        </div>
                        <!-- Create: sequenced assembly -->
                        <div class="type-editor" data-editor="create_sequenced">
                            <div class="type-header">
                                <strong>Create ‚Äì sequenced assembly</strong>
                                <span>Advanced multi-step Create automation</span>
                            </div>

                            <div class="hint tiny">
                                Sequenced assembly recipes have <code>ingredient</code>, a
                                <code>transitionalItem</code>,
                                a repeated <code>sequence</code> of sub-recipes, and final <code>results</code>.
                                :contentReference[oaicite:5]{index=5}
                            </div>

                            <div class="editor-grid-wrapper">
                                <div class="slot-editor" style="flex:1">
                                    <div class="slot-editor-title">
                                        <span>Starting ingredient</span>
                                    </div>
                                    <div class="ingredient-type-row">
                                        <label><input type="radio" name="seqIngredientKind" value="item" checked /> Item
                                            ID</label>
                                        <label><input type="radio" name="seqIngredientKind" value="tag" /> Tag</label>
                                    </div>
                                    <input id="seqIngredientValue" type="text"
                                        placeholder="minecraft:iron_plate or #forge:plates/iron" />
                                    <small class="tiny">
                                        Becomes the <code>ingredient</code> field of the sequenced assembly.
                                    </small>
                                </div>

                                <div class="slot-editor" style="flex:1">
                                    <div class="slot-editor-title">
                                        <span>Transitional item</span>
                                    </div>
                                    <input id="seqTransitionalValue" type="text"
                                        placeholder="create:incomplete_precision_mechanism" />
                                    <small class="tiny">
                                        The item that passes through each step (<code>transitionalItem</code>).
                                    </small>
                                </div>

                                <div class="slot-editor" style="flex:0.7; min-width:160px">
                                    <div class="slot-editor-title">
                                        <span>Loops</span>
                                    </div>
                                    <input id="seqLoopsInput" type="number" min="1" step="1" value="1" />
                                    <small class="tiny">Number of times the <code>sequence</code> repeats.</small>
                                </div>
                            </div>

                            <div class="field">
                                <label for="seqRawSequence">Sequence steps (raw JSON array)</label>
                                <textarea id="seqRawSequence" class="code-textarea"
                                    placeholder='[ { "type": "create:deploying", "ingredients": [...], "results": [...] }, ... ]'></textarea>
                                <small class="tiny">
                                    Paste or edit the <code>sequence</code> array here. Each entry is a normal Create
                                    recipe
                                    (e.g. <code>create:deploying</code>, <code>create:pressing</code>,
                                    <code>create:filling</code>, etc.). :contentReference[oaicite:6]{index=6}
                                </small>
                            </div>
                        </div>
                        <!-- Create: mechanical crafting (resizable grid) -->
                        <div class="type-editor" data-editor="mechanical_crafting">
                            <div class="type-header">
                                <strong>Mechanical crafting pattern</strong>
                                <span>Resize grid and click tiles to set ingredients</span>
                            </div>

                            <div class="editor-grid-wrapper">
                                <div class="grid-card">
                                    <div class="grid-title">Mechanical crafting grid</div>

                                    <div class="field-row tiny" style="margin-bottom:6px;">
                                        <div class="field" style="max-width:120px">
                                            <label>Rows</label>
                                            <input id="mechRowsInput" type="number" min="1" max="9" value="3" />
                                        </div>
                                        <div class="field" style="max-width:120px">
                                            <label>Columns</label>
                                            <input id="mechColsInput" type="number" min="1" max="9" value="3" />
                                        </div>
                                    </div>

                                    <div class="craft-grid" id="mechanicalGrid"></div>
                                    <div class="slot-caption tiny">
                                        Supports up to 9√ó9; empty outer rows/columns are trimmed in the JSON pattern.
                                    </div>
                                </div>

                                <div class="slot-editor" id="mechanicalSlotEditor">
                                    <div class="slot-editor-title">
                                        <span>Selected slot</span>
                                        <span id="mechanicalSlotLabel" class="tiny">None selected</span>
                                    </div>
                                    <div class="ingredient-type-row">
                                        <label><input type="radio" name="mechanicalSlotKind" value="item" checked />
                                            Item ID</label>
                                        <label><input type="radio" name="mechanicalSlotKind" value="tag" /> Tag</label>
                                    </div>
                                    <div class="field">
                                        <label for="mechanicalSlotValue">Item or tag</label>
                                        <input id="mechanicalSlotValue" type="text"
                                            placeholder="minecraft:andesite_alloy" />
                                    </div>
                                    <button class="btn" type="button" id="mechanicalClearSlotBtn">
                                        <span class="btn-icon">üßπ</span> Clear slot
                                    </button>
                                    <div class="ingredient-pill tiny">
                                        Works like the shaped grid, but with a configurable size for Create‚Äôs mechanical
                                        crafting.
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                </section>

                <!-- Right: JSON output -->
                <section class="panel panel-output">
                    <div class="panel-header">
                        <h2>JSON Output</h2>
                        <span>Drop into your data pack under <code>data/&lt;namespace&gt;/recipe/</code></span>
                    </div>
                    <div class="panel-body">
                        <div class="output-path">
                            <div>Recipe file path (1.21+):</div>
                            <code id="filePathPreview">data/mydatapack/recipe/my_cool_recipe.json</code>
                        </div>
                        <div class="output-actions">
                            <button class="btn btn-primary" type="button" id="copyJsonBtn">
                                <span class="btn-icon">üìã</span> Copy JSON
                            </button>
                            <button class="btn" type="button" id="downloadJsonBtn">
                                <span class="btn-icon">üíæ</span> Download <code>.json</code>
                            </button>
                        </div>
                        <div class="output-json-shell">
                            <pre class="output-json" id="jsonOutput">{}</pre>
                            <div class="output-footer-note">
                                This JSON uses the 1.21+ format (e.g. <code>result.id</code> for item stacks).
                                Paste into your data pack or world <code>datapacks/</code> folder.
                            </div>
                        </div>
                    </div>
                </section>
            </div>

            <!-- Tags tab -->
            <div class="tab-panel layout-tags" data-tab-panel="tags" style="display:none">
                <!-- Tag basics -->
                <section class="panel panel-tag-settings">
                    <div class="panel-header">
                        <h2>Tag Basics</h2>
                        <span>Namespace, registry folder &amp; contents</span>
                    </div>
                    <div class="panel-body">
                        <div class="field-row">
                            <div class="field" style="flex:1.1">
                                <label for="tagNsInput">Tag namespace</label>
                                <input id="tagNsInput" type="text" placeholder="mydatapack or minecraft"
                                    value="mydatapack" />
                                <small>Used in
                                    <code>data/&lt;namespace&gt;/tags/&lt;registry&gt;/&lt;path&gt;.json</code></small>
                            </div>
                            <div class="field" style="flex:1">
                                <label for="tagRegistryInput">Registry folder</label>
                                <input id="tagRegistryInput" type="text" placeholder="items" value="items" />
                                <small>Examples: <code>items</code>, <code>blocks</code>, <code>entity_types</code>,
                                    <code>fluids</code>, <code>game_events</code></small>
                            </div>
                        </div>

                        <div class="field-row">
                            <div class="field" style="flex:1.3">
                                <label for="tagPathInput">Tag path (file name)</label>
                                <input id="tagPathInput" type="text" placeholder="my_tag" value="my_tag" />
                                <small>No <code>.json</code> ‚Äì folders allowed, e.g. <code>ores/copper</code></small>
                            </div>
                            <div class="field" style="max-width:170px">
                                <label>&nbsp;</label>
                                <div class="toggle-row">
                                    <input id="tagReplaceToggle" type="checkbox" />
                                    <label for="tagReplaceToggle">replace existing</label>
                                </div>
                                <small class="tiny">Sets <code>"replace": true</code> to overwrite vanilla tags.</small>
                            </div>
                        </div>

                        <div class="field">
                            <label>Values in tag</label>
                            <div id="tagValuesContainer" class="tag-values"></div>
                            <button class="btn" type="button" id="addTagValueBtn">
                                <span class="btn-icon">‚ûï</span> Add value
                            </button>
                            <small class="tiny">
                                Choose <b>Item / block ID</b> for entries like <code>minecraft:stone</code>, or <b>Tag
                                    (#)</b> to include another tag,
                                which will be written as <code>#namespace:other_tag</code>.
                            </small>
                        </div>
                    </div>
                </section>

                <!-- Tag JSON output -->
                <section class="panel panel-tag-output">
                    <div class="panel-header">
                        <h2>Tag JSON</h2>
                        <span>Drop into <code>data/&lt;namespace&gt;/tags/&lt;registry&gt;/</code></span>
                    </div>
                    <div class="panel-body">
                        <div class="output-path">
                            <div>Tag file path:</div>
                            <code id="tagFilePathPreview">data/mydatapack/tags/items/my_tag.json</code>
                        </div>
                        <div class="output-actions">
                            <button class="btn btn-primary" type="button" id="tagCopyJsonBtn">
                                <span class="btn-icon">üìã</span> Copy JSON
                            </button>
                            <button class="btn" type="button" id="tagDownloadJsonBtn">
                                <span class="btn-icon">üíæ</span> Download <code>.json</code>
                            </button>
                        </div>
                        <div class="output-json-shell">
                            <pre class="output-json" id="tagJsonOutput">{}</pre>
                            <div class="output-footer-note">
                                Standard tag format: <code>{"replace": false, "values": [...]}</code>.
                                Works for any registry folder you specify under <code>tags/</code>.
                            </div>
                        </div>
                    </div>
                </section>
            </div>
        </main>
    </div>

    <div class="toast" id="toast">
        <span>‚úî</span>
        <div id="toastText">Copied!</div>
    </div>

    <script>
        // --- Small helpers -------------------------------------------------------
        function showToast(message) {
            const toast = document.getElementById('toast');
            const text = document.getElementById('toastText');
            text.textContent = message;
            toast.classList.add('show');
            setTimeout(() => {
                toast.classList.remove('show');
            }, 1600);
        }

        function cloneIngredient(kind, value) {
            if (!kind || !value) return null;
            return { kind, value };
        }

        function ingredientToJson(ing) {
            if (!ing || !ing.value || !ing.value.trim) return null;
            if (!ing.value.trim()) return null;
            const v = ing.value.trim();
            if (!v) return null;
            if (ing.kind === 'tag') {
                return { tag: v };
            }
            return { item: v };
        }

        // --- State ---------------------------------------------------------------
        const state = {
            namespace: 'mydatapack',
            path: 'my_cool_recipe',
            resultItem: '',
            resultCount: 1,
            group: '',
            category: 'misc',
            showNotification: true, // if false => show_notification: false
            typeId: 'minecraft:crafting_shaped',
            editorKey: 'crafting_shaped',

            shaped: {
                grid: Array.from({ length: 3 }, () =>
                    Array.from({ length: 3 }, () => null)
                ),
                selected: null
            },
            mechanical: {
                rows: 3,
                cols: 3,
                grid: Array.from({ length: 3 }, () =>
                    Array.from({ length: 3 }, () => null)
                ),
                selected: null
            },
            shapeless: {
                grid: Array.from({ length: 3 }, () =>
                    Array.from({ length: 3 }, () => null)
                ),
                selected: null
            },
            cooking: {
                ingredient: { kind: 'item', value: '' },
                experience: 0.1,
                cookingTime: 200
            },
            stonecut: {
                ingredient: { kind: 'item', value: '' },
                count: 1
            },
            smithingTransform: {
                template: { kind: 'item', value: '' },
                base: { kind: 'item', value: '' },
                addition: { kind: 'item', value: '' }
            },
            smithingTrim: {
                template: { kind: 'item', value: '' },
                base: { kind: 'item', value: '' },
                addition: { kind: 'item', value: '' }
            },
            specialTypeId: 'minecraft:crafting_special_armordye',

            tags: {
                namespace: 'mydatapack',
                registry: 'items',
                path: 'my_tag',
                replace: false,
                values: []
            },

            // --- Create mod recipe state -------------------------------------------
            createProcessing: {
                ingredients: [], // { kind: 'item'|'tag'|'fluid', id, amount }
                results: [],     // { kind: 'item'|'tag'|'fluid', id, count, amount, chance }
                processingTime: 100,
                heatRequirement: ''
            },

            createSequenced: {
                ingredient: { kind: 'item', value: '' },
                transitionalItem: '',
                loops: 1,
                rawSequence: ''
            },

            // --- Farmer's Delight recipe state ------------------------------------
            fdCooking: {
                ingredients: [],          // [{ kind: 'item'|'tag', value: '...' }]
                containerItem: '',        // container.item (e.g. minecraft:bowl)
                cookingTime: 200,         // cookingtime
                experience: 0,            // experience
                recipeBookTab: ''         // '', 'meals', 'drinks', 'misc'
            },

            fdCutting: {
                ingredient: { kind: 'item', value: '' }, // single input on the board
                tool: {
                    mode: 'tag',         // 'tag' | 'item' | 'type'
                    tag: '',             // e.g. forge:tools/knives
                    item: '',            // e.g. farmersdelight:iron_knife
                    toolType: ''         // e.g. axe, shovel (for farmersdelight:tool)
                },
                results: [],             // [{ id, count, chance }]
                sound: ''                // optional sound ID
            }
        };

        const recipeTypes = [
            // --- Vanilla crafting ---------------------------------------------------
            {
                id: 'minecraft:crafting_shaped',
                label: 'Shaped',
                description: 'Pattern-based 3√ó3 crafting',
                group: 'Crafting',
                icon: 'üß±',
                editorKey: 'crafting_shaped'
            },
            {
                id: 'minecraft:crafting_shapeless',
                label: 'Shapeless',
                description: 'Order doesn‚Äôt matter',
                group: 'Crafting',
                icon: '‚ú®',
                editorKey: 'crafting_shapeless'
            },
            {
                id: 'minecraft:crafting_decorated_pot',
                label: 'Decorated pot',
                description: 'Special pot serializer',
                group: 'Crafting',
                icon: 'üè∫',
                editorKey: 'crafting_decorated_pot'
            },

            // --- Vanilla cooking ----------------------------------------------------
            {
                id: 'minecraft:smelting',
                label: 'Smelting',
                description: 'Furnace recipes',
                group: 'Cooking',
                icon: 'üî•',
                editorKey: 'cooking'
            },
            {
                id: 'minecraft:blasting',
                label: 'Blasting',
                description: 'Blast furnace',
                group: 'Cooking',
                icon: '‚ö°',
                editorKey: 'cooking'
            },
            {
                id: 'minecraft:smoking',
                label: 'Smoking',
                description: 'Smoker',
                group: 'Cooking',
                icon: 'üí®',
                editorKey: 'cooking'
            },
            {
                id: 'minecraft:campfire_cooking',
                label: 'Campfire',
                description: 'Campfire cooking',
                group: 'Cooking',
                icon: 'üèïÔ∏è',
                editorKey: 'cooking'
            },

            // --- Vanilla other ------------------------------------------------------
            {
                id: 'minecraft:stonecutting',
                label: 'Stonecutting',
                description: 'Stonecutter recipes',
                group: 'Stonecutting',
                icon: 'ü™®',
                editorKey: 'stonecutting'
            },
            {
                id: 'minecraft:smithing_transform',
                label: 'Smithing transform',
                description: 'Upgrades (e.g. netherite)',
                group: 'Smithing',
                icon: '‚öôÔ∏è',
                editorKey: 'smithing_transform'
            },
            {
                id: 'minecraft:smithing_trim',
                label: 'Smithing trim',
                description: 'Armor trims',
                group: 'Smithing',
                icon: 'üé®',
                editorKey: 'smithing_trim'
            },

            // --- Vanilla special crafting ------------------------------------------
            {
                id: 'minecraft:crafting_special_armordye',
                label: 'Armor dye (special)',
                description: 'Built-in serializer',
                group: 'Special',
                icon: 'üõ°Ô∏è',
                editorKey: 'crafting_special'
            },
            {
                id: 'minecraft:crafting_special_bannerduplicate',
                label: 'Banner duplicate',
                description: 'Built-in serializer',
                group: 'Special',
                icon: 'üè≥Ô∏è',
                editorKey: 'crafting_special'
            },
            {
                id: 'minecraft:crafting_special_bookcloning',
                label: 'Book cloning',
                description: 'Built-in serializer',
                group: 'Special',
                icon: 'üìò',
                editorKey: 'crafting_special'
            },
            {
                id: 'minecraft:crafting_special_firework_rocket',
                label: 'Firework rocket',
                description: 'Built-in serializer',
                group: 'Special',
                icon: 'üéÜ',
                editorKey: 'crafting_special'
            },
            {
                id: 'minecraft:crafting_special_firework_star',
                label: 'Firework star',
                description: 'Built-in serializer',
                group: 'Special',
                icon: '‚≠ê',
                editorKey: 'crafting_special'
            },
            {
                id: 'minecraft:crafting_special_firework_star_fade',
                label: 'Firework star fade',
                description: 'Built-in serializer',
                group: 'Special',
                icon: 'üåà',
                editorKey: 'crafting_special'
            },
            {
                id: 'minecraft:crafting_special_mapcloning',
                label: 'Map cloning',
                description: 'Built-in serializer',
                group: 'Special',
                icon: 'üó∫Ô∏è',
                editorKey: 'crafting_special'
            },
            {
                id: 'minecraft:crafting_special_mapextending',
                label: 'Map extending',
                description: 'Built-in serializer',
                group: 'Special',
                icon: '‚ûï',
                editorKey: 'crafting_special'
            },
            {
                id: 'minecraft:crafting_special_repairitem',
                label: 'Repair item',
                description: 'Built-in serializer',
                group: 'Special',
                icon: 'üîß',
                editorKey: 'crafting_special'
            },
            {
                id: 'minecraft:crafting_special_shielddecoration',
                label: 'Shield decoration',
                description: 'Built-in serializer',
                group: 'Special',
                icon: 'üõ°Ô∏è',
                editorKey: 'crafting_special'
            },
            {
                id: 'minecraft:crafting_special_shulkerboxcoloring',
                label: 'Shulker box color',
                description: 'Built-in serializer',
                group: 'Special',
                icon: 'üì¶',
                editorKey: 'crafting_special'
            },
            {
                id: 'minecraft:crafting_special_tippedarrow',
                label: 'Tipped arrows',
                description: 'Built-in serializer',
                group: 'Special',
                icon: 'üèπ',
                editorKey: 'crafting_special'
            },
            {
                id: 'minecraft:crafting_special_suspiciousstew',
                label: 'Suspicious stew',
                description: 'Built-in serializer',
                group: 'Special',
                icon: 'ü•£',
                editorKey: 'crafting_special'
            },
            {
                id: 'minecraft:crafting_transmute',
                label: 'Transmute',
                description: 'Experimental special',
                group: 'Special',
                icon: 'üîÆ',
                editorKey: 'crafting_special'
            },

            // --- Create mod: generic processing types ------------------------------
            {
                id: 'create:compacting',
                label: 'Compacting',
                description: 'Mechanical press (compacting)',
                group: 'Create',
                icon: 'üßä',
                editorKey: 'create_processing'
            },
            {
                id: 'create:crushing',
                label: 'Crushing',
                description: 'Crushing wheels',
                group: 'Create',
                icon: 'üåÄ',
                editorKey: 'create_processing'
            },
            {
                id: 'create:cutting',
                label: 'Cutting',
                description: 'Mechanical saw',
                group: 'Create',
                icon: 'ü™ö',
                editorKey: 'create_processing'
            },
            {
                id: 'create:deploying',
                label: 'Deploying',
                description: 'Deployer recipes',
                group: 'Create',
                icon: 'ü§ö',
                editorKey: 'create_processing'
            },
            {
                id: 'create:emptying',
                label: 'Emptying',
                description: 'Item drain (emptying)',
                group: 'Create',
                icon: 'üß¥',
                editorKey: 'create_processing'
            },
            {
                id: 'create:filling',
                label: 'Filling',
                description: 'Spout (filling)',
                group: 'Create',
                icon: 'üíß',
                editorKey: 'create_processing'
            },
            {
                id: 'create:haunting',
                label: 'Haunting',
                description: 'Fan with soul fire',
                group: 'Create',
                icon: 'üëª',
                editorKey: 'create_processing'
            },
            {
                id: 'create:item_application',
                label: 'Item application',
                description: 'Use item on block',
                group: 'Create',
                icon: 'üß©',
                editorKey: 'create_processing'
            },
            {
                id: 'create:milling',
                label: 'Milling',
                description: 'Millstone',
                group: 'Create',
                icon: 'üåæ',
                editorKey: 'create_processing'
            },
            {
                id: 'create:mixing',
                label: 'Mixing',
                description: 'Mechanical mixer / basin',
                group: 'Create',
                icon: 'ü•£',
                editorKey: 'create_processing'
            },
            {
                id: 'create:pressing',
                label: 'Pressing',
                description: 'Mechanical press',
                group: 'Create',
                icon: 'üìÄ',
                editorKey: 'create_processing'
            },
            {
                id: 'create:sandpaper_polishing',
                label: 'Sandpaper polishing',
                description: 'Sandpaper polishing',
                group: 'Create',
                icon: 'ü™£',
                editorKey: 'create_processing'
            },
            {
                id: 'create:splashing',
                label: 'Splashing',
                description: 'Fan with water',
                group: 'Create',
                icon: 'üí¶',
                editorKey: 'create_processing'
            },

            // --- Create mod: mechanical crafting -----------------------------------
            {
                id: 'create:mechanical_crafting',
                label: 'Mechanical crafting',
                description: 'Mechanical crafters, shaped pattern',
                group: 'Create',
                icon: '‚öôÔ∏è',
                editorKey: 'mechanical_crafting'
            },

            // --- Create mod: sequenced assembly ------------------------------------
            {
                id: 'create:sequenced_assembly',
                label: 'Sequenced assembly',
                description: 'Multi-step Create processing',
                group: 'Create',
                icon: 'üß¨',
                editorKey: 'create_sequenced'
            },

            // --- Farmer's Delight ----------------------------------------------------
            {
                id: 'farmersdelight:cooking',
                label: 'FD cooking pot',
                description: 'Farmer\'s Delight cooking pot',
                group: 'Farmer\'s Delight',
                icon: 'üç≤',
                editorKey: 'fd_cooking'
            },
            {
                id: 'farmersdelight:cutting',
                label: 'FD cutting board',
                description: 'Farmer\'s Delight cutting board',
                group: 'Farmer\'s Delight',
                icon: 'üî™',
                editorKey: 'fd_cutting'
            },
            {
                id: 'farmersdelight:decomposition',
                label: 'FD decomposition',
                description: 'Decomposition (compost-like)',
                group: 'Farmer\'s Delight',
                icon: 'ü™±',
                editorKey: 'fd_decomposition'
            },
        ];

        // --- UI setup ------------------------------------------------------------
        function buildTypeChips() {
            const container = document.getElementById('typeChips');
            container.innerHTML = '';

            const searchEl = document.getElementById('typeSearchInput');
            const query = searchEl && searchEl.value
                ? searchEl.value.toLowerCase()
                : '';

            // Always show a "Vanilla" header at the top
            const vanillaDivider = document.createElement('div');
            vanillaDivider.className = 'recipe-divider';
            vanillaDivider.textContent = 'Vanilla recipes';
            container.appendChild(vanillaDivider);

            let fdDividerAdded = false;
            let createDividerAdded = false;

            recipeTypes.forEach(rt => {
                // Simple search filter on label / id / description / group
                if (query) {
                    const haystack = (
                        rt.label + ' ' +
                        rt.description + ' ' +
                        rt.id + ' ' +
                        rt.group
                    ).toLowerCase();
                    if (!haystack.includes(query)) {
                        return;
                    }
                }

                if (rt.group === 'Farmer\'s Delight' && !fdDividerAdded) {
                    const fdDivider = document.createElement('div');
                    fdDivider.className = 'recipe-divider';
                    fdDivider.textContent = 'Farmer\'s Delight recipes';
                    container.appendChild(fdDivider);
                    fdDividerAdded = true;
                }

                if (rt.group === 'Create' && !createDividerAdded) {
                    const createDivider = document.createElement('div');
                    createDivider.className = 'recipe-divider';
                    createDivider.textContent = 'Create recipes';
                    container.appendChild(createDivider);
                    createDividerAdded = true;
                }

                const chip = document.createElement('button');
                chip.type = 'button';
                chip.className = 'chip';
                chip.dataset.typeId = rt.id;
                chip.dataset.editorKey = rt.editorKey;

                const main = document.createElement('div');
                main.className = 'chip-main';

                const icon = document.createElement('div');
                icon.className = 'chip-icon';
                icon.textContent = rt.icon;

                const label = document.createElement('div');
                label.className = 'chip-label';
                const strong = document.createElement('strong');
                strong.textContent = rt.label;
                const span = document.createElement('span');
                span.textContent = rt.description;
                label.appendChild(strong);
                label.appendChild(span);

                main.appendChild(icon);
                main.appendChild(label);

                const meta = document.createElement('div');
                meta.className = 'chip-meta';
                meta.textContent = rt.group.toUpperCase();

                chip.appendChild(main);
                chip.appendChild(meta);

                chip.addEventListener('click', () => {
                    selectRecipeType(rt.id, rt.editorKey, true);
                });

                container.appendChild(chip);
            });
        }

        function selectRecipeType(typeId, editorKey, fromUser) {
            state.typeId = typeId;
            state.editorKey = editorKey;

            // Highlight chip
            const chips = document.querySelectorAll('.chip');
            chips.forEach(chip => {
                const chipType = chip.dataset.typeId;
                chip.classList.toggle('selected', chipType === typeId);
            });

            // Show correct editor
            const editors = document.querySelectorAll('.type-editor');
            editors.forEach(ed => {
                const key = ed.dataset.editor;
                ed.classList.toggle('active', key === editorKey);
            });

            // Update Create processing subtitle to show current type
            const createLabel = document.getElementById('createProcessingTypeLabel');
            if (createLabel) {
                const rt = recipeTypes.find(r => r.id === typeId);
                if (rt && editorKey === 'create_processing') {
                    createLabel.textContent = `Currently editing: ${typeId}`;
                } else if (rt && createLabel.textContent.startsWith('Currently editing:')) {
                    // Keep last used type visible even when switching editors
                    createLabel.textContent = `Currently editing: ${typeId}`;
                }
            }

            // For crafting_special, sync dropdown to typeId if it‚Äôs one of the specials
            if (editorKey === 'crafting_special') {
                const select = document.getElementById('specialTypeSelect');
                if (typeId.startsWith('minecraft:crafting_special_') || typeId === 'minecraft:crafting_transmute') {
                    select.value = typeId;
                    state.specialTypeId = typeId;
                } else {
                    if (state.specialTypeId) {
                        select.value = state.specialTypeId;
                    }
                }
            }

            if (fromUser) {
                updateJsonPreview();
            }
        }

        // Build 3√ó3 grids for shaped & shapeless
        function buildGrid(gridId, stateKey) {
            const gridEl = document.getElementById(gridId);
            gridEl.innerHTML = '';
            for (let row = 0; row < 3; row++) {
                for (let col = 0; col < 3; col++) {
                    const slot = document.createElement('button');
                    slot.type = 'button';
                    slot.className = 'craft-slot';
                    slot.dataset.row = row;
                    slot.dataset.col = col;
                    const textSpan = document.createElement('span');
                    textSpan.textContent = '';
                    slot.appendChild(textSpan);
                    slot.addEventListener('click', () => {
                        selectGridSlot(stateKey, row, col);
                    });
                    gridEl.appendChild(slot);
                }
            }
        }

        function selectGridSlot(stateKey, row, col) {
            const gridSelector = stateKey === 'shaped' ? '#shapedGrid .craft-slot' : '#shapelessGrid .craft-slot';
            const slots = document.querySelectorAll(gridSelector);
            slots.forEach(s => {
                const r = Number(s.dataset.row);
                const c = Number(s.dataset.col);
                s.classList.toggle('selected', r === row && c === col);
            });

            const stateObj = state[stateKey];
            stateObj.selected = { row, col };

            const ing = stateObj.grid[row][col];

            if (stateKey === 'shaped') {
                const label = document.getElementById('shapedSlotLabel');
                label.textContent = `Row ${row + 1}, Col ${col + 1}`;
                const radios = document.querySelectorAll('input[name="shapedSlotKind"]');
                const valueInput = document.getElementById('shapedSlotValue');
                if (ing) {
                    radios.forEach(r => {
                        r.checked = r.value === ing.kind;
                    });
                    valueInput.value = ing.value;
                } else {
                    radios.forEach(r => {
                        r.checked = r.value === 'item';
                    });
                    valueInput.value = '';
                }
            } else if (stateKey === 'shapeless') {
                const label = document.getElementById('shapelessSlotLabel');
                label.textContent = `Slot #${row * 3 + col + 1}`;
                const radios = document.querySelectorAll('input[name="shapelessSlotKind"]');
                const valueInput = document.getElementById('shapelessSlotValue');
                if (ing) {
                    radios.forEach(r => {
                        r.checked = r.value === ing.kind;
                    });
                    valueInput.value = ing.value;
                } else {
                    radios.forEach(r => {
                        r.checked = r.value === 'item';
                    });
                    valueInput.value = '';
                }
            }
        }

        function resizeMechanicalGrid(newRows, newCols) {
            const oldGrid = state.mechanical.grid;
            const oldRows = oldGrid.length;
            const oldCols = oldGrid[0]?.length || 0;

            const grid = Array.from({ length: newRows }, (_, r) =>
                Array.from({ length: newCols }, (_, c) =>
                    r < oldRows && c < oldCols ? oldGrid[r][c] : null
                )
            );

            state.mechanical.rows = newRows;
            state.mechanical.cols = newCols;
            state.mechanical.grid = grid;
            state.mechanical.selected = null;
        }

        function refreshMechanicalGridLabels() {
            const slots = document.querySelectorAll('#mechanicalGrid .craft-slot');
            const grid = state.mechanical.grid;

            slots.forEach(slot => {
                const row = Number(slot.dataset.row);
                const col = Number(slot.dataset.col);
                const ing = grid[row][col];
                const span = slot.querySelector('span');
                if (!ing || !ing.value || !ing.value.trim()) {
                    span.textContent = '';
                } else if (ing.kind === 'tag') {
                    span.textContent = '#' + ing.value.replace(/^minecraft:/, '');
                } else {
                    span.textContent = ing.value.replace(/^minecraft:/, '');
                }
            });
        }

        function buildMechanicalGrid() {
            const gridEl = document.getElementById('mechanicalGrid');
            if (!gridEl) return;

            const { rows, cols, grid } = state.mechanical;
            gridEl.innerHTML = '';
            gridEl.style.gridTemplateColumns = `repeat(${cols}, 44px)`;
            gridEl.style.gridTemplateRows = `repeat(${rows}, 44px)`;

            for (let r = 0; r < rows; r++) {
                for (let c = 0; c < cols; c++) {
                    const slot = document.createElement('button');
                    slot.type = 'button';
                    slot.className = 'craft-slot';
                    slot.dataset.row = r;
                    slot.dataset.col = c;

                    const span = document.createElement('span');
                    slot.appendChild(span);

                    slot.addEventListener('click', () => {
                        selectMechanicalSlot(r, c);
                    });

                    gridEl.appendChild(slot);
                }
            }

            refreshMechanicalGridLabels();
        }

        function selectMechanicalSlot(row, col) {
            const slots = document.querySelectorAll('#mechanicalGrid .craft-slot');
            slots.forEach(s => {
                const r = Number(s.dataset.row);
                const c = Number(s.dataset.col);
                s.classList.toggle('selected', r === row && c === col);
            });

            state.mechanical.selected = { row, col };

            const ing = state.mechanical.grid[row][col];
            const label = document.getElementById('mechanicalSlotLabel');
            const radios = document.querySelectorAll('input[name="mechanicalSlotKind"]');
            const valueInput = document.getElementById('mechanicalSlotValue');

            label.textContent = `Row ${row + 1}, Col ${col + 1}`;

            if (ing) {
                radios.forEach(r => { r.checked = r.value === ing.kind; });
                valueInput.value = ing.value;
            } else {
                radios.forEach(r => { r.checked = r.value === 'item'; });
                valueInput.value = '';
            }
        }

        function refreshGridLabels(stateKey) {
            const selector = stateKey === 'shaped' ? '#shapedGrid .craft-slot' : '#shapelessGrid .craft-slot';
            const slots = document.querySelectorAll(selector);
            const grid = state[stateKey].grid;

            slots.forEach(slot => {
                const row = Number(slot.dataset.row);
                const col = Number(slot.dataset.col);
                const ing = grid[row][col];
                const span = slot.querySelector('span');
                if (!ing || !ing.value.trim()) {
                    span.textContent = '';
                } else if (ing.kind === 'tag') {
                    span.textContent = '#' + ing.value.replace(/^minecraft:/, '');
                } else {
                    span.textContent = ing.value.replace(/^minecraft:/, '');
                }
            });
        }

        // --- JSON builders (recipes) ---------------------------------------------
        function buildFdCookingRecipe() {
            const recipe = {
                type: 'farmersdelight:cooking'
            };
            applyCommonRecipeFields(recipe);

            // ingredients[]
            const ingredients = (state.fdCooking.ingredients || [])
                .map(ing => ingredientToJson(ing || {}))
                .filter(Boolean);
            if (ingredients.length) {
                recipe.ingredients = ingredients;
            }

            // result object from global result stack
            const resultStack = buildResultStack();
            if (resultStack) {
                const res = { item: resultStack.id };
                if (resultStack.count && resultStack.count !== 1) {
                    res.count = resultStack.count;
                }
                recipe.result = res;
            }

            // container
            const containerId = state.fdCooking.containerItem && state.fdCooking.containerItem.trim();
            if (containerId) {
                recipe.container = { item: containerId };
            }

            // cookingtime / experience
            const t = Number(state.fdCooking.cookingTime);
            if (!Number.isNaN(t) && t > 0) {
                recipe.cookingtime = t;
            }
            const exp = Number(state.fdCooking.experience);
            if (!Number.isNaN(exp) && exp > 0) {
                recipe.experience = exp;
            }

            // recipe_book_tab
            const tab = state.fdCooking.recipeBookTab && state.fdCooking.recipeBookTab.trim();
            if (tab) {
                recipe.recipe_book_tab = tab;
            }

            return recipe;
        }

        function buildFdCuttingRecipe() {
            const recipe = {
                type: 'farmersdelight:cutting'
            };
            applyCommonRecipeFields(recipe);

            // ingredients: single entry in array
            const ingJson = ingredientToJson(state.fdCutting.ingredient || {});
            if (ingJson) {
                recipe.ingredients = [ingJson];
            }

            // tool
            const toolJson = buildFdCuttingToolJson();
            if (toolJson) {
                recipe.tool = toolJson;
            }

            // results[]
            const results = (state.fdCutting.results || [])
                .map(r => {
                    if (!r || !r.id || !r.id.trim()) return null;
                    const obj = { item: r.id.trim() };
                    const cnt = Number(r.count);
                    if (!Number.isNaN(cnt) && cnt > 1) {
                        obj.count = cnt;
                    }
                    if (r.chance !== undefined && r.chance !== null && r.chance !== '') {
                        const ch = Number(r.chance);
                        if (!Number.isNaN(ch) && ch >= 0 && ch <= 1) {
                            obj.chance = ch;
                        }
                    }
                    return obj;
                })
                .filter(Boolean);
            if (results.length) {
                recipe.result = results;
            }

            const soundId = state.fdCutting.sound && state.fdCutting.sound.trim();
            if (soundId) {
                recipe.sound = soundId;
            }

            return recipe;
        }

        function buildFdDecompositionRecipe() {
            const recipe = {
                type: 'farmersdelight:decomposition'
            };
            applyCommonRecipeFields(recipe);
            // No extra fields here: JSON layout is mod-specific and not clearly documented.
            // Users can take this skeleton and extend it manually.
            return recipe;
        }

        function buildFdCuttingToolJson() {
            const toolState = state.fdCutting.tool || {};
            const mode = toolState.mode || 'tag';

            if (mode === 'tag') {
                const tagId = toolState.tag && toolState.tag.trim();
                if (tagId) return { tag: tagId };
            } else if (mode === 'item') {
                const itemId = toolState.item && toolState.item.trim();
                if (itemId) return { item: itemId };
            } else if (mode === 'type') {
                const tt = toolState.toolType && toolState.toolType.trim();
                if (tt) return { type: 'farmersdelight:tool', tool: tt };
            }

            return null;
        }

        function buildCreateProcessingRecipe(typeId) {
            const recipe = { type: typeId };

            ensureCreateProcessingDefaults();

            const ings = state.createProcessing.ingredients
                .map(row => buildCreateEntryFromRow(row, false))
                .filter(Boolean);
            if (ings.length) {
                recipe.ingredients = ings;
            }

            const res = state.createProcessing.results
                .map(row => buildCreateEntryFromRow(row, true))
                .filter(Boolean);
            if (res.length) {
                recipe.results = res;
            }

            if (createTypesWithProcessingTime.has(typeId)) {
                const t = Number(state.createProcessing.processingTime);
                if (!Number.isNaN(t) && t > 0) {
                    recipe.processingTime = t;
                }
            }

            if (createTypesWithHeatRequirement.has(typeId)) {
                const heat = state.createProcessing.heatRequirement && state.createProcessing.heatRequirement.trim();
                if (heat) {
                    recipe.heatRequirement = heat;
                }
            }

            return recipe;
        }

        function buildCreateMechanicalRecipe() {
            const { rows, cols, grid } = state.mechanical;
            let minRow = rows, maxRow = -1, minCol = cols, maxCol = -1;

            for (let r = 0; r < rows; r++) {
                for (let c = 0; c < cols; c++) {
                    if (grid[r][c] && grid[r][c].value && grid[r][c].value.trim()) {
                        if (r < minRow) minRow = r;
                        if (r > maxRow) maxRow = r;
                        if (c < minCol) minCol = c;
                        if (c > maxCol) maxCol = c;
                    }
                }
            }

            const recipe = { type: 'create:mechanical_crafting' };

            if (maxRow === -1) {
                recipe.pattern = [];
                recipe.key = {};
            } else {
                const pattern = [];
                const ingredientMap = {};
                const reverseMap = {};
                const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789!@#$%^&*?';
                let idx = 0;

                function ingredientKey(ing) {
                    const j = ingredientToJson(ing);
                    return j ? JSON.stringify(j) : null;
                }

                for (let r = minRow; r <= maxRow; r++) {
                    let rowStr = '';
                    for (let c = minCol; c <= maxCol; c++) {
                        const ing = grid[r][c];
                        const key = ing && ing.value && ing.value.trim() ? ingredientKey(ing) : null;
                        if (!key) {
                            rowStr += ' ';
                        } else {
                            if (!(key in reverseMap)) {
                                const ch = chars[idx++] || '?';
                                reverseMap[key] = ch;
                                ingredientMap[ch] = ingredientToJson(ing);
                            }
                            rowStr += reverseMap[key];
                        }
                    }
                    pattern.push(rowStr);
                }

                recipe.pattern = pattern;
                recipe.key = ingredientMap;
            }

            if (state.resultItem && state.resultItem.trim()) {
                const count = Number(state.resultCount) || 1;
                const res = { item: state.resultItem.trim() };
                if (count !== 1) res.count = count;
                recipe.result = res;
            }

            return recipe;
        }

        function buildCreateSequencedRecipe() {
            const recipe = { type: 'create:sequenced_assembly' };

            const ing = ingredientToJson(state.createSequenced.ingredient || {});
            if (ing) {
                recipe.ingredient = ing;
            }

            if (state.createSequenced.transitionalItem && state.createSequenced.transitionalItem.trim()) {
                recipe.transitionalItem = state.createSequenced.transitionalItem.trim();
            }

            const loops = Number(state.createSequenced.loops);
            if (!Number.isNaN(loops) && loops > 0) {
                recipe.loops = loops;
            }

            if (state.createSequenced.rawSequence && state.createSequenced.rawSequence.trim()) {
                try {
                    const seq = JSON.parse(state.createSequenced.rawSequence);
                    if (Array.isArray(seq)) {
                        recipe.sequence = seq;
                    }
                } catch (err) {
                    console.warn('Invalid sequenced_assembly sequence JSON; sequence omitted.', err);
                }
            }

            return recipe;
        }

        const createTypesWithProcessingTime = new Set([
            'create:crushing',
            'create:cutting',
            'create:milling'
        ]);

        const createTypesWithHeatRequirement = new Set([
            'create:mixing',
            'create:compacting'
        ]);

        function applyCommonRecipeFields(obj) {
            if (state.group && state.group.trim()) {
                obj.group = state.group.trim();
            }
            if (state.category && state.category !== 'none') {
                obj.category = state.category;
            }
            if (!state.showNotification) {
                obj.show_notification = false;
            }
            return obj;
        }

        function buildResultStack() {
            if (!state.resultItem || !state.resultItem.trim()) return null;
            const count = Number(state.resultCount) || 1;
            return count === 1
                ? { id: state.resultItem.trim() }
                : { id: state.resultItem.trim(), count };
        }

        function buildShapedRecipe() {
            const recipe = {
                type: 'minecraft:crafting_shaped'
            };
            applyCommonRecipeFields(recipe);

            const grid = state.shaped.grid;
            let minRow = 3, maxRow = -1, minCol = 3, maxCol = -1;

            for (let r = 0; r < 3; r++) {
                for (let c = 0; c < 3; c++) {
                    if (grid[r][c] && grid[r][c].value.trim()) {
                        if (r < minRow) minRow = r;
                        if (r > maxRow) maxRow = r;
                        if (c < minCol) minCol = c;
                        if (c > maxCol) maxCol = c;
                    }
                }
            }

            if (maxRow === -1) {
                recipe.pattern = [];
                recipe.key = {};
            } else {
                const pattern = [];
                const ingredientMap = {};
                const reverseMap = {};
                const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789!@#$%^&*?';
                let idx = 0;

                function ingredientKey(ing) {
                    const j = ingredientToJson(ing);
                    return j ? JSON.stringify(j) : null;
                }

                for (let r = minRow; r <= maxRow; r++) {
                    let rowStr = '';
                    for (let c = minCol; c <= maxCol; c++) {
                        const ing = grid[r][c];
                        const key = ing && ing.value.trim() ? ingredientKey(ing) : null;
                        if (!key) {
                            rowStr += ' ';
                        } else {
                            if (!(key in reverseMap)) {
                                const ch = chars[idx++] || '?';
                                reverseMap[key] = ch;
                                ingredientMap[ch] = ingredientToJson(ing);
                            }
                            rowStr += reverseMap[key];
                        }
                    }
                    pattern.push(rowStr);
                }
                recipe.pattern = pattern;
                recipe.key = ingredientMap;
            }

            const resultStack = buildResultStack();
            if (resultStack) {
                recipe.result = resultStack;
            }
            return recipe;
        }

        function buildShapelessRecipe() {
            const recipe = {
                type: 'minecraft:crafting_shapeless'
            };
            applyCommonRecipeFields(recipe);

            const grid = state.shapeless.grid;
            const ingredients = [];

            for (let r = 0; r < 3; r++) {
                for (let c = 0; c < 3; c++) {
                    const ing = grid[r][c];
                    const j = ingredientToJson(ing || {});
                    if (j) {
                        ingredients.push(j);
                    }
                }
            }

            recipe.ingredients = ingredients;
            const resultStack = buildResultStack();
            if (resultStack) {
                recipe.result = resultStack;
            }
            return recipe;
        }

        function buildCookingRecipe(typeId) {
            const recipe = {
                type: typeId
            };
            applyCommonRecipeFields(recipe);

            const ingredientJson = ingredientToJson(state.cooking.ingredient || {});
            if (ingredientJson) {
                recipe.ingredient = ingredientJson;
            }

            const resultStack = buildResultStack();
            if (resultStack) {
                recipe.result = resultStack.id;
            }

            recipe.experience = Number(state.cooking.experience) || 0;
            recipe.cookingtime = Number(state.cooking.cookingTime) || 200;

            return recipe;
        }

        function buildStonecuttingRecipe() {
            const recipe = {
                type: 'minecraft:stonecutting'
            };
            applyCommonRecipeFields(recipe);

            const ingredientJson = ingredientToJson(state.stonecut.ingredient || {});
            if (ingredientJson) {
                recipe.ingredient = ingredientJson;
            }

            const resultStack = buildResultStack();
            if (resultStack) {
                recipe.result = resultStack.id;
                recipe.count = Number(state.stonecut.count) || 1;
            }

            return recipe;
        }

        function buildSmithingTransformRecipe() {
            const recipe = {
                type: 'minecraft:smithing_transform'
            };
            applyCommonRecipeFields(recipe);

            const t = ingredientToJson(state.smithingTransform.template || {});
            const b = ingredientToJson(state.smithingTransform.base || {});
            const a = ingredientToJson(state.smithingTransform.addition || {});

            if (t) recipe.template = t;
            if (b) recipe.base = b;
            if (a) recipe.addition = a;

            const resultStack = buildResultStack();
            if (resultStack) {
                recipe.result = resultStack;
            }

            return recipe;
        }

        function buildSmithingTrimRecipe() {
            const recipe = {
                type: 'minecraft:smithing_trim'
            };
            applyCommonRecipeFields(recipe);

            const t = ingredientToJson(state.smithingTrim.template || {});
            const b = ingredientToJson(state.smithingTrim.base || {});
            const a = ingredientToJson(state.smithingTrim.addition || {});

            if (t) recipe.template = t;
            if (b) recipe.base = b;
            if (a) recipe.addition = a;

            return recipe;
        }

        function buildDecoratedPotRecipe() {
            const recipe = {
                type: 'minecraft:crafting_decorated_pot'
            };
            applyCommonRecipeFields(recipe);
            return recipe;
        }

        function buildSpecialRecipe() {
            const typeId = state.specialTypeId || 'minecraft:crafting_special_armordye';
            const recipe = { type: typeId };
            applyCommonRecipeFields(recipe);
            return recipe;
        }

        function buildRecipeJson() {
            const typeId = state.typeId;

            switch (typeId) {
                // Vanilla
                case 'minecraft:crafting_shaped':
                    return buildShapedRecipe();
                case 'minecraft:crafting_shapeless':
                    return buildShapelessRecipe();
                case 'minecraft:smelting':
                case 'minecraft:blasting':
                case 'minecraft:smoking':
                case 'minecraft:campfire_cooking':
                    return buildCookingRecipe(typeId);
                case 'minecraft:stonecutting':
                    return buildStonecuttingRecipe();
                case 'minecraft:smithing_transform':
                    return buildSmithingTransformRecipe();
                case 'minecraft:smithing_trim':
                    return buildSmithingTrimRecipe();
                case 'minecraft:crafting_decorated_pot':
                    return buildDecoratedPotRecipe();

                // Create: generic processing types
                case 'create:compacting':
                case 'create:crushing':
                case 'create:cutting':
                case 'create:deploying':
                case 'create:emptying':
                case 'create:filling':
                case 'create:haunting':
                case 'create:item_application':
                case 'create:milling':
                case 'create:mixing':
                case 'create:pressing':
                case 'create:sandpaper_polishing':
                case 'create:splashing':
                    return buildCreateProcessingRecipe(typeId);

                // Create: mechanical crafting
                case 'create:mechanical_crafting':
                    return buildCreateMechanicalRecipe();

                // Create: sequenced assembly
                case 'create:sequenced_assembly':
                    return buildCreateSequencedRecipe();

                // Farmer's Delight ------------------------------------------------
                case 'farmersdelight:cooking':
                    return buildFdCookingRecipe();
                case 'farmersdelight:cutting':
                    return buildFdCuttingRecipe();
                case 'farmersdelight:decomposition':
                    return buildFdDecompositionRecipe();

                // Everything else is a vanilla "special" recipe type
                default:
                    return buildSpecialRecipe();
            }
        }

        function updateFilePathPreview() {
            const ns = state.namespace && state.namespace.trim() ? state.namespace.trim() : 'namespace';
            const path = state.path && state.path.trim() ? state.path.trim() : 'recipe_name';
            const text = `data/${ns}/recipe/${path}.json`;
            document.getElementById('filePathPreview').textContent = text;
        }

        function updateJsonPreview() {
            const jsonObj = buildRecipeJson();
            const jsonStr = JSON.stringify(jsonObj, null, 2);
            document.getElementById('jsonOutput').textContent = jsonStr;
            updateFilePathPreview();
        }

        // --- Tag JSON builder ----------------------------------------------------
        function buildTagJson() {
            const rawValues = state.tags.values || [];
            const values = rawValues
                .map(v => {
                    if (!v || !v.value || !v.value.trim()) return null;
                    const kind = v.kind || 'item';
                    const id = v.value.trim();
                    if (kind === 'tag') {
                        return id.startsWith('#') ? id : `#${id}`;
                    }
                    return id;
                })
                .filter(Boolean);

            return {
                replace: !!state.tags.replace,
                values
            };
        }

        function ensureCreateProcessingDefaults() {
            if (!state.createProcessing.ingredients || state.createProcessing.ingredients.length === 0) {
                state.createProcessing.ingredients = [{ kind: 'item', id: '', amount: null }];
            }
            if (!state.createProcessing.results || state.createProcessing.results.length === 0) {
                state.createProcessing.results = [{ kind: 'item', id: '', count: 1, amount: null, chance: '' }];
            }
            if (typeof state.createProcessing.processingTime !== 'number') {
                state.createProcessing.processingTime = 100;
            }
            if (typeof state.createProcessing.heatRequirement !== 'string') {
                state.createProcessing.heatRequirement = '';
            }
        }

        function buildCreateEntryFromRow(row, isResult) {
            if (!row || !row.id || !row.id.trim()) return null;
            const id = row.id.trim();
            const kind = row.kind || 'item';
            const entry = {};

            if (kind === 'fluid') {
                entry.fluid = id;
                const amt = Number(row.amount);
                if (!Number.isNaN(amt) && amt > 0) {
                    entry.amount = amt;
                }
            } else if (kind === 'tag') {
                entry.tag = id;
                const cnt = Number(row.count);
                if (isResult && !Number.isNaN(cnt) && cnt > 1) {
                    entry.count = cnt;
                }
            } else {
                entry.item = id;
                const cnt = Number(row.count);
                if (!Number.isNaN(cnt) && cnt > 1) {
                    entry.count = cnt;
                }
            }

            if (isResult && row.chance !== undefined && row.chance !== null && row.chance !== '') {
                const chance = Number(row.chance);
                if (!Number.isNaN(chance) && chance > 0 && chance <= 1) {
                    entry.chance = chance;
                }
            }

            return entry;
        }

        function renderCreateProcessing() {
            ensureCreateProcessingDefaults();

            const ingContainer = document.getElementById('createIngredientsContainer');
            const resContainer = document.getElementById('createResultsContainer');
            if (!ingContainer || !resContainer) return;

            ingContainer.innerHTML = '';
            resContainer.innerHTML = '';

            // Ingredients
            state.createProcessing.ingredients.forEach((entry, index) => {
                const row = document.createElement('div');
                row.className = 'tag-value-row';

                const kindWrap = document.createElement('div');
                kindWrap.className = 'tag-value-kind';
                const kindSelect = document.createElement('select');
                ['item', 'tag', 'fluid'].forEach(kind => {
                    const opt = document.createElement('option');
                    opt.value = kind;
                    opt.textContent = kind === 'fluid' ? 'Fluid' : (kind === 'tag' ? 'Tag' : 'Item ID');
                    kindSelect.appendChild(opt);
                });
                kindSelect.value = entry.kind || 'item';
                kindSelect.addEventListener('change', e => {
                    entry.kind = e.target.value;
                    updateJsonPreview();
                });
                kindWrap.appendChild(kindSelect);

                const valueWrap = document.createElement('div');
                valueWrap.className = 'tag-value-input';
                const valueInput = document.createElement('input');
                valueInput.type = 'text';
                valueInput.placeholder = 'minecraft:iron_ore or create:zinc_ore';
                valueInput.value = entry.id || '';
                valueInput.addEventListener('input', e => {
                    entry.id = e.target.value;
                    updateJsonPreview();
                });
                valueWrap.appendChild(valueInput);

                const amountWrap = document.createElement('div');
                amountWrap.style.maxWidth = '90px';
                const amountInput = document.createElement('input');
                amountInput.type = 'number';
                amountInput.min = '0';
                amountInput.placeholder = 'amt';
                amountInput.value = entry.amount != null ? entry.amount : '';
                amountInput.addEventListener('input', e => {
                    const v = e.target.value;
                    entry.amount = v === '' ? null : Number(v) || 0;
                    updateJsonPreview();
                });
                amountWrap.appendChild(amountInput);

                const removeBtn = document.createElement('button');
                removeBtn.type = 'button';
                removeBtn.className = 'btn tag-remove-btn';
                removeBtn.textContent = '‚úï';
                removeBtn.title = 'Remove ingredient';
                removeBtn.addEventListener('click', () => {
                    state.createProcessing.ingredients.splice(index, 1);
                    renderCreateProcessing();
                    updateJsonPreview();
                });

                row.appendChild(kindWrap);
                row.appendChild(valueWrap);
                row.appendChild(amountWrap);
                row.appendChild(removeBtn);
                ingContainer.appendChild(row);
            });

            // Results
            state.createProcessing.results.forEach((entry, index) => {
                const row = document.createElement('div');
                row.className = 'tag-value-row';

                const kindWrap = document.createElement('div');
                kindWrap.className = 'tag-value-kind';
                const kindSelect = document.createElement('select');
                ['item', 'fluid'].forEach(kind => {
                    const opt = document.createElement('option');
                    opt.value = kind;
                    opt.textContent = kind === 'fluid' ? 'Fluid' : 'Item ID';
                    kindSelect.appendChild(opt);
                });
                kindSelect.value = entry.kind || 'item';
                kindSelect.addEventListener('change', e => {
                    entry.kind = e.target.value;
                    updateJsonPreview();
                });
                kindWrap.appendChild(kindSelect);

                const valueWrap = document.createElement('div');
                valueWrap.className = 'tag-value-input';
                const valueInput = document.createElement('input');
                valueInput.type = 'text';
                valueInput.placeholder = 'Result item or fluid ID';
                valueInput.value = entry.id || '';
                valueInput.addEventListener('input', e => {
                    entry.id = e.target.value;
                    updateJsonPreview();
                });
                valueWrap.appendChild(valueInput);

                const countWrap = document.createElement('div');
                countWrap.style.maxWidth = '70px';
                const countInput = document.createElement('input');
                countInput.type = 'number';
                countInput.min = '0';
                countInput.placeholder = 'cnt';
                countInput.value = entry.count != null ? entry.count : '';
                countInput.addEventListener('input', e => {
                    const v = e.target.value;
                    entry.count = v === '' ? null : Number(v) || 0;
                    updateJsonPreview();
                });
                countWrap.appendChild(countInput);

                const chanceWrap = document.createElement('div');
                chanceWrap.style.maxWidth = '80px';
                const chanceInput = document.createElement('input');
                chanceInput.type = 'number';
                chanceInput.step = '0.05';
                chanceInput.min = '0';
                chanceInput.max = '1';
                chanceInput.placeholder = 'chance';
                chanceInput.value = entry.chance != null ? entry.chance : '';
                chanceInput.addEventListener('input', e => {
                    const v = e.target.value;
                    entry.chance = v === '' ? '' : Number(v) || 0;
                    updateJsonPreview();
                });
                chanceWrap.appendChild(chanceInput);

                const removeBtn = document.createElement('button');
                removeBtn.type = 'button';
                removeBtn.className = 'btn tag-remove-btn';
                removeBtn.textContent = '‚úï';
                removeBtn.title = 'Remove result';
                removeBtn.addEventListener('click', () => {
                    state.createProcessing.results.splice(index, 1);
                    renderCreateProcessing();
                    updateJsonPreview();
                });

                row.appendChild(kindWrap);
                row.appendChild(valueWrap);
                row.appendChild(countWrap);
                row.appendChild(chanceWrap);
                row.appendChild(removeBtn);
                resContainer.appendChild(row);
            });
        }

        function renderFdCookingIngredients() {
            const container = document.getElementById('fdCookingIngredientsContainer');
            if (!container) return;

            container.innerHTML = '';

            if (!state.fdCooking.ingredients || state.fdCooking.ingredients.length === 0) {
                state.fdCooking.ingredients = [{ kind: 'item', value: '' }];
            }

            state.fdCooking.ingredients.forEach((entry, index) => {
                const row = document.createElement('div');
                row.className = 'tag-value-row';

                const kindWrap = document.createElement('div');
                kindWrap.className = 'tag-value-kind';
                const kindSelect = document.createElement('select');
                ['item', 'tag'].forEach(kind => {
                    const opt = document.createElement('option');
                    opt.value = kind;
                    opt.textContent = kind === 'tag' ? 'Tag' : 'Item ID';
                    kindSelect.appendChild(opt);
                });
                kindSelect.value = entry.kind || 'item';
                kindSelect.addEventListener('change', e => {
                    entry.kind = e.target.value;
                    updateJsonPreview();
                });
                kindWrap.appendChild(kindSelect);

                const valueWrap = document.createElement('div');
                valueWrap.className = 'tag-value-input';
                const valueInput = document.createElement('input');
                valueInput.type = 'text';
                valueInput.placeholder = 'minecraft:wheat or farmersdelight:onion';
                valueInput.value = entry.value || '';
                valueInput.addEventListener('input', e => {
                    entry.value = e.target.value;
                    updateJsonPreview();
                });
                valueWrap.appendChild(valueInput);

                const removeBtn = document.createElement('button');
                removeBtn.type = 'button';
                removeBtn.className = 'btn tag-remove-btn';
                removeBtn.textContent = '‚úï';
                removeBtn.title = 'Remove ingredient';
                removeBtn.addEventListener('click', () => {
                    state.fdCooking.ingredients.splice(index, 1);
                    renderFdCookingIngredients();
                    updateJsonPreview();
                });

                row.appendChild(kindWrap);
                row.appendChild(valueWrap);
                row.appendChild(removeBtn);
                container.appendChild(row);
            });
        }

        function renderFdCutting() {
            const ingContainer = document.getElementById('fdCuttingIngredientContainer');
            const resContainer = document.getElementById('fdCuttingResultsContainer');
            if (!ingContainer || !resContainer) return;

            // Ingredient (single)
            ingContainer.innerHTML = '';
            if (!state.fdCutting.ingredient) {
                state.fdCutting.ingredient = { kind: 'item', value: '' };
            }
            const entry = state.fdCutting.ingredient;

            const row = document.createElement('div');
            row.className = 'tag-value-row';

            const kindWrap = document.createElement('div');
            kindWrap.className = 'tag-value-kind';
            const kindSelect = document.createElement('select');
            ['item', 'tag'].forEach(kind => {
                const opt = document.createElement('option');
                opt.value = kind;
                opt.textContent = kind === 'tag' ? 'Tag' : 'Item ID';
                kindSelect.appendChild(opt);
            });
            kindSelect.value = entry.kind || 'item';
            kindSelect.addEventListener('change', e => {
                entry.kind = e.target.value;
                updateJsonPreview();
            });
            kindWrap.appendChild(kindSelect);

            const valueWrap = document.createElement('div');
            valueWrap.className = 'tag-value-input';
            const valueInput = document.createElement('input');
            valueInput.type = 'text';
            valueInput.placeholder = 'Item to cut';
            valueInput.value = entry.value || '';
            valueInput.addEventListener('input', e => {
                entry.value = e.target.value;
                updateJsonPreview();
            });
            valueWrap.appendChild(valueInput);

            row.appendChild(kindWrap);
            row.appendChild(valueWrap);
            ingContainer.appendChild(row);

            // Results
            resContainer.innerHTML = '';
            if (!state.fdCutting.results || state.fdCutting.results.length === 0) {
                state.fdCutting.results = [{ id: '', count: 1, chance: '' }];
            }

            state.fdCutting.results.forEach((res, index) => {
                const rRow = document.createElement('div');
                rRow.className = 'tag-value-row';

                const idWrap = document.createElement('div');
                idWrap.className = 'tag-value-input';
                const idInput = document.createElement('input');
                idInput.type = 'text';
                idInput.placeholder = 'Result item ID';
                idInput.value = res.id || '';
                idInput.addEventListener('input', e => {
                    res.id = e.target.value;
                    updateJsonPreview();
                });
                idWrap.appendChild(idInput);

                const countWrap = document.createElement('div');
                countWrap.style.maxWidth = '70px';
                const countInput = document.createElement('input');
                countInput.type = 'number';
                countInput.min = '0';
                countInput.placeholder = 'cnt';
                countInput.value = res.count != null ? res.count : '';
                countInput.addEventListener('input', e => {
                    const v = e.target.value;
                    res.count = v === '' ? null : Number(v) || 0;
                    updateJsonPreview();
                });
                countWrap.appendChild(countInput);

                const chanceWrap = document.createElement('div');
                chanceWrap.style.maxWidth = '80px';
                const chanceInput = document.createElement('input');
                chanceInput.type = 'number';
                chanceInput.step = '0.05';
                chanceInput.min = '0';
                chanceInput.max = '1';
                chanceInput.placeholder = 'chance';
                chanceInput.value = res.chance != null ? res.chance : '';
                chanceInput.addEventListener('input', e => {
                    const v = e.target.value;
                    res.chance = v === '' ? '' : Number(v) || 0;
                    updateJsonPreview();
                });
                chanceWrap.appendChild(chanceInput);

                const removeBtn = document.createElement('button');
                removeBtn.type = 'button';
                removeBtn.className = 'btn tag-remove-btn';
                removeBtn.textContent = '‚úï';
                removeBtn.title = 'Remove result';
                removeBtn.addEventListener('click', () => {
                    state.fdCutting.results.splice(index, 1);
                    renderFdCutting();
                    updateJsonPreview();
                });

                rRow.appendChild(idWrap);
                rRow.appendChild(countWrap);
                rRow.appendChild(chanceWrap);
                rRow.appendChild(removeBtn);
                resContainer.appendChild(rRow);
            });
        }

        function updateTagFilePathPreview() {
            const ns = state.tags.namespace && state.tags.namespace.trim()
                ? state.tags.namespace.trim()
                : 'namespace';
            const registry = state.tags.registry && state.tags.registry.trim()
                ? state.tags.registry.trim()
                : 'items';
            const path = state.tags.path && state.tags.path.trim()
                ? state.tags.path.trim()
                : 'tag_name';
            document.getElementById('tagFilePathPreview').textContent =
                `data/${ns}/tags/${registry}/${path}.json`;
        }

        function updateTagJsonPreview() {
            const obj = buildTagJson();
            const jsonStr = JSON.stringify(obj, null, 2);
            document.getElementById('tagJsonOutput').textContent = jsonStr;
            updateTagFilePathPreview();
        }

        function renderTagValues() {
            const container = document.getElementById('tagValuesContainer');
            container.innerHTML = '';

            if (!state.tags.values || state.tags.values.length === 0) {
                state.tags.values = [{ kind: 'item', value: '' }];
            }

            state.tags.values.forEach((entry, index) => {
                const row = document.createElement('div');
                row.className = 'tag-value-row';

                const kindWrap = document.createElement('div');
                kindWrap.className = 'tag-value-kind';
                const kindSelect = document.createElement('select');
                const optItem = document.createElement('option');
                optItem.value = 'item';
                optItem.textContent = 'Item / block ID';
                const optTag = document.createElement('option');
                optTag.value = 'tag';
                optTag.textContent = 'Tag (#)';
                kindSelect.appendChild(optItem);
                kindSelect.appendChild(optTag);
                kindSelect.value = entry.kind || 'item';
                kindSelect.addEventListener('change', e => {
                    entry.kind = e.target.value;
                    updateTagJsonPreview();
                });
                kindWrap.appendChild(kindSelect);

                const valueWrap = document.createElement('div');
                valueWrap.className = 'tag-value-input';
                const valueInput = document.createElement('input');
                valueInput.type = 'text';
                valueInput.placeholder = 'minecraft:stone or minecraft:logs';
                valueInput.value = entry.value || '';
                valueInput.addEventListener('input', e => {
                    entry.value = e.target.value;
                    updateTagJsonPreview();
                });
                valueWrap.appendChild(valueInput);

                const removeBtn = document.createElement('button');
                removeBtn.type = 'button';
                removeBtn.className = 'btn tag-remove-btn';
                removeBtn.textContent = '‚úï';
                removeBtn.title = 'Remove value';
                removeBtn.addEventListener('click', () => {
                    state.tags.values.splice(index, 1);
                    renderTagValues();
                    updateTagJsonPreview();
                });

                row.appendChild(kindWrap);
                row.appendChild(valueWrap);
                row.appendChild(removeBtn);

                container.appendChild(row);
            });
        }

        // --- Tabs ----------------------------------------------------------------
        function setupTabs() {
            const tabButtons = document.querySelectorAll('.tab-button');
            const panels = document.querySelectorAll('.tab-panel');

            tabButtons.forEach(btn => {
                btn.addEventListener('click', () => {
                    const tab = btn.dataset.tab;
                    tabButtons.forEach(b => b.classList.toggle('active', b === btn));
                    panels.forEach(panel => {
                        const isMatch = panel.dataset.tabPanel === tab;
                        panel.style.display = isMatch ? '' : 'none';
                    });
                });
            });
        }

        // --- Input bindings ------------------------------------------------------
        function bindInputs() {
            const typeSearchInput = document.getElementById('typeSearchInput');
            if (typeSearchInput) {
                typeSearchInput.addEventListener('input', () => {
                    buildTypeChips();
                });
            }
            // Global settings (recipes)
            document.getElementById('nsInput').addEventListener('input', e => {
                state.namespace = e.target.value;
                updateJsonPreview();
            });
            document.getElementById('pathInput').addEventListener('input', e => {
                state.path = e.target.value;
                updateJsonPreview();
            });
            document.getElementById('resultItemInput').addEventListener('input', e => {
                state.resultItem = e.target.value;
                updateJsonPreview();
            });
            document.getElementById('resultCountInput').addEventListener('input', e => {
                const n = Number(e.target.value) || 1;
                state.resultCount = n;
                updateJsonPreview();
            });
            document.getElementById('groupInput').addEventListener('input', e => {
                state.group = e.target.value;
                updateJsonPreview();
            });
            document.getElementById('categorySelect').addEventListener('change', e => {
                state.category = e.target.value;
                updateJsonPreview();
            });
            document.getElementById('showNotificationToggle').addEventListener('change', e => {
                state.showNotification = e.target.checked;
                updateJsonPreview();
            });

            // Shaped slot editor
            const shapedKindRadios = document.querySelectorAll('input[name="shapedSlotKind"]');
            shapedKindRadios.forEach(r => {
                r.addEventListener('change', () => {
                    const sel = state.shaped.selected;
                    if (!sel) return;
                    const valueEl = document.getElementById('shapedSlotValue');
                    const kind = document.querySelector('input[name="shapedSlotKind"]:checked').value;
                    const value = valueEl.value.trim();
                    state.shaped.grid[sel.row][sel.col] = value ? cloneIngredient(kind, value) : null;
                    refreshGridLabels('shaped');
                    updateJsonPreview();
                });
            });
            document.getElementById('shapedSlotValue').addEventListener('input', e => {
                const sel = state.shaped.selected;
                if (!sel) return;
                const kind = document.querySelector('input[name="shapedSlotKind"]:checked').value;
                const value = e.target.value.trim();
                state.shaped.grid[sel.row][sel.col] = value ? cloneIngredient(kind, value) : null;
                refreshGridLabels('shaped');
                updateJsonPreview();
            });
            document.getElementById('shapedClearSlotBtn').addEventListener('click', () => {
                const sel = state.shaped.selected;
                if (!sel) return;
                state.shaped.grid[sel.row][sel.col] = null;
                document.getElementById('shapedSlotValue').value = '';
                refreshGridLabels('shaped');
                updateJsonPreview();
            });

            // Shapeless slot editor
            const shapelessKindRadios = document.querySelectorAll('input[name="shapelessSlotKind"]');
            shapelessKindRadios.forEach(r => {
                r.addEventListener('change', () => {
                    const sel = state.shapeless.selected;
                    if (!sel) return;
                    const valueEl = document.getElementById('shapelessSlotValue');
                    const kind = document.querySelector('input[name="shapelessSlotKind"]:checked').value;
                    const value = valueEl.value.trim();
                    state.shapeless.grid[sel.row][sel.col] = value ? cloneIngredient(kind, value) : null;
                    refreshGridLabels('shapeless');
                    updateJsonPreview();
                });
            });
            document.getElementById('shapelessSlotValue').addEventListener('input', e => {
                const sel = state.shapeless.selected;
                if (!sel) return;
                const kind = document.querySelector('input[name="shapelessSlotKind"]:checked').value;
                const value = e.target.value.trim();
                state.shapeless.grid[sel.row][sel.col] = value ? cloneIngredient(kind, value) : null;
                refreshGridLabels('shapeless');
                updateJsonPreview();
            });
            document.getElementById('shapelessClearSlotBtn').addEventListener('click', () => {
                const sel = state.shapeless.selected;
                if (!sel) return;
                state.shapeless.grid[sel.row][sel.col] = null;
                document.getElementById('shapelessSlotValue').value = '';
                refreshGridLabels('shapeless');
                updateJsonPreview();
            });

            // Mechanical crafting slot editor
            const mechKindRadios = document.querySelectorAll('input[name="mechanicalSlotKind"]');
            mechKindRadios.forEach(r => {
                r.addEventListener('change', () => {
                    const sel = state.mechanical.selected;
                    if (!sel) return;
                    const valueEl = document.getElementById('mechanicalSlotValue');
                    const kind = document.querySelector('input[name="mechanicalSlotKind"]:checked').value;
                    const value = valueEl.value.trim();
                    state.mechanical.grid[sel.row][sel.col] = value ? cloneIngredient(kind, value) : null;
                    refreshMechanicalGridLabels();
                    updateJsonPreview();
                });
            });

            const mechValueInput = document.getElementById('mechanicalSlotValue');
            if (mechValueInput) {
                mechValueInput.addEventListener('input', e => {
                    const sel = state.mechanical.selected;
                    if (!sel) return;
                    const kind = document.querySelector('input[name="mechanicalSlotKind"]:checked').value;
                    const value = e.target.value.trim();
                    state.mechanical.grid[sel.row][sel.col] = value ? cloneIngredient(kind, value) : null;
                    refreshMechanicalGridLabels();
                    updateJsonPreview();
                });
            }

            const mechClearBtn = document.getElementById('mechanicalClearSlotBtn');
            if (mechClearBtn) {
                mechClearBtn.addEventListener('click', () => {
                    const sel = state.mechanical.selected;
                    if (!sel) return;
                    state.mechanical.grid[sel.row][sel.col] = null;
                    document.getElementById('mechanicalSlotValue').value = '';
                    refreshMechanicalGridLabels();
                    updateJsonPreview();
                });
            }

            // Cooking
            const cookKindRadios = document.querySelectorAll('input[name="cookKind"]');
            cookKindRadios.forEach(r => {
                r.addEventListener('change', () => {
                    const kind = document.querySelector('input[name="cookKind"]:checked').value;
                    state.cooking.ingredient.kind = kind;
                    updateJsonPreview();
                });
            });
            document.getElementById('cookValue').addEventListener('input', e => {
                state.cooking.ingredient.value = e.target.value;
                updateJsonPreview();
            });
            document.getElementById('cookExpInput').addEventListener('input', e => {
                state.cooking.experience = Number(e.target.value) || 0;
                updateJsonPreview();
            });
            document.getElementById('cookTimeInput').addEventListener('input', e => {
                state.cooking.cookingTime = Number(e.target.value) || 200;
                updateJsonPreview();
            });

            // Stonecutting
            const stoneKindRadios = document.querySelectorAll('input[name="stoneKind"]');
            stoneKindRadios.forEach(r => {
                r.addEventListener('change', () => {
                    const kind = document.querySelector('input[name="stoneKind"]:checked').value;
                    state.stonecut.ingredient.kind = kind;
                    updateJsonPreview();
                });
            });
            document.getElementById('stoneValue').addEventListener('input', e => {
                state.stonecut.ingredient.value = e.target.value;
                updateJsonPreview();
            });
            document.getElementById('stoneCountInput').addEventListener('input', e => {
                state.stonecut.count = Number(e.target.value) || 1;
                updateJsonPreview();
            });

            // Smithing transform
            const smithTemplateRadios = document.querySelectorAll('input[name="smithTemplateKind"]');
            smithTemplateRadios.forEach(r => {
                r.addEventListener('change', () => {
                    const kind = document.querySelector('input[name="smithTemplateKind"]:checked').value;
                    state.smithingTransform.template.kind = kind;
                    updateJsonPreview();
                });
            });
            document.getElementById('smithTemplateValue').addEventListener('input', e => {
                state.smithingTransform.template.value = e.target.value;
                updateJsonPreview();
            });

            const smithBaseRadios = document.querySelectorAll('input[name="smithBaseKind"]');
            smithBaseRadios.forEach(r => {
                r.addEventListener('change', () => {
                    const kind = document.querySelector('input[name="smithBaseKind"]:checked').value;
                    state.smithingTransform.base.kind = kind;
                    updateJsonPreview();
                });
            });
            document.getElementById('smithBaseValue').addEventListener('input', e => {
                state.smithingTransform.base.value = e.target.value;
                updateJsonPreview();
            });

            const smithAddRadios = document.querySelectorAll('input[name="smithAddKind"]');
            smithAddRadios.forEach(r => {
                r.addEventListener('change', () => {
                    const kind = document.querySelector('input[name="smithAddKind"]:checked').value;
                    state.smithingTransform.addition.kind = kind;
                    updateJsonPreview();
                });
            });
            document.getElementById('smithAddValue').addEventListener('input', e => {
                state.smithingTransform.addition.value = e.target.value;
                updateJsonPreview();
            });

            // Smithing trim
            const trimTemplateRadios = document.querySelectorAll('input[name="trimTemplateKind"]');
            trimTemplateRadios.forEach(r => {
                r.addEventListener('change', () => {
                    const kind = document.querySelector('input[name="trimTemplateKind"]:checked').value;
                    state.smithingTrim.template.kind = kind;
                    updateJsonPreview();
                });
            });
            document.getElementById('trimTemplateValue').addEventListener('input', e => {
                state.smithingTrim.template.value = e.target.value;
                updateJsonPreview();
            });

            const trimBaseRadios = document.querySelectorAll('input[name="trimBaseKind"]');
            trimBaseRadios.forEach(r => {
                r.addEventListener('change', () => {
                    const kind = document.querySelector('input[name="trimBaseKind"]:checked').value;
                    state.smithingTrim.base.kind = kind;
                    updateJsonPreview();
                });
            });
            document.getElementById('trimBaseValue').addEventListener('input', e => {
                state.smithingTrim.base.value = e.target.value;
                updateJsonPreview();
            });

            const trimAddRadios = document.querySelectorAll('input[name="trimAddKind"]');
            trimAddRadios.forEach(r => {
                r.addEventListener('change', () => {
                    const kind = document.querySelector('input[name="trimAddKind"]:checked').value;
                    state.smithingTrim.addition.kind = kind;
                    updateJsonPreview();
                });
            });
            document.getElementById('trimAddValue').addEventListener('input', e => {
                state.smithingTrim.addition.value = e.target.value;
                updateJsonPreview();
            });

            // Special type selector
            document.getElementById('specialTypeSelect').addEventListener('change', e => {
                state.specialTypeId = e.target.value;
                state.typeId = state.specialTypeId;
                const chip = Array.from(document.querySelectorAll('.chip')).find(c => c.dataset.typeId === state.specialTypeId);
                if (chip) {
                    selectRecipeType(state.specialTypeId, 'crafting_special', false);
                }
                updateJsonPreview();
            });

            // Output actions (recipes)
            document.getElementById('copyJsonBtn').addEventListener('click', async () => {
                const jsonStr = document.getElementById('jsonOutput').textContent;
                try {
                    if (navigator.clipboard && navigator.clipboard.writeText) {
                        await navigator.clipboard.writeText(jsonStr);
                    } else {
                        const ta = document.createElement('textarea');
                        ta.value = jsonStr;
                        ta.style.position = 'fixed';
                        ta.style.opacity = '0';
                        document.body.appendChild(ta);
                        ta.focus();
                        ta.select();
                        document.execCommand('copy');
                        document.body.removeChild(ta);
                    }
                    showToast('JSON copied to clipboard');
                } catch (err) {
                    console.error(err);
                    showToast('Could not copy JSON');
                }
            });

            document.getElementById('downloadJsonBtn').addEventListener('click', () => {
                const jsonStr = document.getElementById('jsonOutput').textContent;
                const blob = new Blob([jsonStr], { type: 'application/json' });
                const url = URL.createObjectURL(blob);
                const ns = state.namespace && state.namespace.trim() ? state.namespace.trim() : 'namespace';
                const path = state.path && state.path.trim() ? state.path.trim() : 'recipe_name';
                const a = document.createElement('a');
                a.href = url;
                a.download = `${ns}-${path.replace(/[\\/]/g, '_')}.json`;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
            });

            // --- Tag inputs ---
            document.getElementById('tagNsInput').addEventListener('input', e => {
                state.tags.namespace = e.target.value;
                updateTagJsonPreview();
            });

            document.getElementById('tagRegistryInput').addEventListener('input', e => {
                state.tags.registry = e.target.value;
                updateTagJsonPreview();
            });

            document.getElementById('tagPathInput').addEventListener('input', e => {
                state.tags.path = e.target.value;
                updateTagJsonPreview();
            });

            document.getElementById('tagReplaceToggle').addEventListener('change', e => {
                state.tags.replace = e.target.checked;
                updateTagJsonPreview();
            });

            document.getElementById('addTagValueBtn').addEventListener('click', () => {
                state.tags.values.push({ kind: 'item', value: '' });
                renderTagValues();
                updateTagJsonPreview();
            });

            document.getElementById('tagCopyJsonBtn').addEventListener('click', async () => {
                const jsonStr = document.getElementById('tagJsonOutput').textContent;
                try {
                    if (navigator.clipboard && navigator.clipboard.writeText) {
                        await navigator.clipboard.writeText(jsonStr);
                    } else {
                        const ta = document.createElement('textarea');
                        ta.value = jsonStr;
                        ta.style.position = 'fixed';
                        ta.style.opacity = '0';
                        document.body.appendChild(ta);
                        ta.focus();
                        ta.select();
                        document.execCommand('copy');
                        document.body.removeChild(ta);
                    }
                    showToast('Tag JSON copied to clipboard');
                } catch (err) {
                    console.error(err);
                    showToast('Could not copy JSON');
                }
            });

            document.getElementById('tagDownloadJsonBtn').addEventListener('click', () => {
                const jsonStr = document.getElementById('tagJsonOutput').textContent;
                const blob = new Blob([jsonStr], { type: 'application/json' });
                const url = URL.createObjectURL(blob);
                const ns = state.tags.namespace && state.tags.namespace.trim()
                    ? state.tags.namespace.trim()
                    : 'namespace';
                const registry = state.tags.registry && state.tags.registry.trim()
                    ? state.tags.registry.trim()
                    : 'items';
                const path = state.tags.path && state.tags.path.trim()
                    ? state.tags.path.trim()
                    : 'tag_name';
                const a = document.createElement('a');
                a.href = url;
                a.download = `${ns}-tag-${registry}-${path.replace(/[\\/]/g, '_')}.json`;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
            });

            // --- Create processing inputs ---
            const addCreateIngredientBtn = document.getElementById('addCreateIngredientBtn');
            if (addCreateIngredientBtn) {
                addCreateIngredientBtn.addEventListener('click', () => {
                    state.createProcessing.ingredients.push({ kind: 'item', id: '', amount: null });
                    renderCreateProcessing();
                    updateJsonPreview();
                });
            }

            const addCreateResultBtn = document.getElementById('addCreateResultBtn');
            if (addCreateResultBtn) {
                addCreateResultBtn.addEventListener('click', () => {
                    state.createProcessing.results.push({ kind: 'item', id: '', count: 1, amount: null, chance: '' });
                    renderCreateProcessing();
                    updateJsonPreview();
                });
            }

            const createProcTimeInput = document.getElementById('createProcessingTimeInput');
            if (createProcTimeInput) {
                createProcTimeInput.addEventListener('input', e => {
                    const v = e.target.value;
                    state.createProcessing.processingTime = v === '' ? 0 : Number(v) || 0;
                    updateJsonPreview();
                });
            }

            const createHeatSelect = document.getElementById('createHeatRequirementSelect');
            if (createHeatSelect) {
                createHeatSelect.addEventListener('change', e => {
                    state.createProcessing.heatRequirement = e.target.value;
                    updateJsonPreview();
                });
            }

            // --- Create sequenced assembly inputs ---
            const seqIngredientRadios = document.querySelectorAll('input[name="seqIngredientKind"]');
            seqIngredientRadios.forEach(r => {
                r.addEventListener('change', () => {
                    const kind = document.querySelector('input[name="seqIngredientKind"]:checked').value;
                    state.createSequenced.ingredient.kind = kind;
                    updateJsonPreview();
                });
            });

            const seqIngValue = document.getElementById('seqIngredientValue');
            if (seqIngValue) {
                seqIngValue.addEventListener('input', e => {
                    state.createSequenced.ingredient.value = e.target.value;
                    updateJsonPreview();
                });
            }

            const seqTransitionalValue = document.getElementById('seqTransitionalValue');
            if (seqTransitionalValue) {
                seqTransitionalValue.addEventListener('input', e => {
                    state.createSequenced.transitionalItem = e.target.value;
                    updateJsonPreview();
                });
            }

            const seqLoopsInput = document.getElementById('seqLoopsInput');
            if (seqLoopsInput) {
                seqLoopsInput.addEventListener('input', e => {
                    const v = Number(e.target.value);
                    state.createSequenced.loops = Number.isNaN(v) || v <= 0 ? 1 : v;
                    updateJsonPreview();
                });
            }

            const seqRawSequence = document.getElementById('seqRawSequence');
            if (seqRawSequence) {
                seqRawSequence.addEventListener('input', e => {
                    state.createSequenced.rawSequence = e.target.value;
                    updateJsonPreview();
                });
            }

            const mechRowsInput = document.getElementById('mechRowsInput');
            if (mechRowsInput) {
                mechRowsInput.addEventListener('input', e => {
                    let v = Number(e.target.value) || 1;
                    v = Math.max(1, Math.min(9, v)); // clamp to 1‚Äì9
                    e.target.value = v;
                    resizeMechanicalGrid(v, state.mechanical.cols);
                    buildMechanicalGrid();
                    updateJsonPreview();
                });
            }

            const mechColsInput = document.getElementById('mechColsInput');
            if (mechColsInput) {
                mechColsInput.addEventListener('input', e => {
                    let v = Number(e.target.value) || 1;
                    v = Math.max(1, Math.min(9, v)); // clamp to 1‚Äì9
                    e.target.value = v;
                    resizeMechanicalGrid(state.mechanical.rows, v);
                    buildMechanicalGrid();
                    updateJsonPreview();
                });
            }

            // --- Farmer's Delight: cooking pot inputs -----------------------------
            const addFdCookingIngredientBtn = document.getElementById('addFdCookingIngredientBtn');
            if (addFdCookingIngredientBtn) {
                addFdCookingIngredientBtn.addEventListener('click', () => {
                    state.fdCooking.ingredients.push({ kind: 'item', value: '' });
                    renderFdCookingIngredients();
                    updateJsonPreview();
                });
            }

            const fdCookingTimeInput = document.getElementById('fdCookingTimeInput');
            if (fdCookingTimeInput) {
                fdCookingTimeInput.addEventListener('input', e => {
                    const v = Number(e.target.value);
                    state.fdCooking.cookingTime = Number.isNaN(v) ? 0 : v;
                    updateJsonPreview();
                });
            }

            const fdCookingExpInput = document.getElementById('fdCookingExpInput');
            if (fdCookingExpInput) {
                fdCookingExpInput.addEventListener('input', e => {
                    const v = Number(e.target.value);
                    state.fdCooking.experience = Number.isNaN(v) ? 0 : v;
                    updateJsonPreview();
                });
            }

            const fdCookingContainerInput = document.getElementById('fdCookingContainerInput');
            if (fdCookingContainerInput) {
                fdCookingContainerInput.addEventListener('input', e => {
                    state.fdCooking.containerItem = e.target.value;
                    updateJsonPreview();
                });
            }

            const fdCookingTabSelect = document.getElementById('fdCookingTabSelect');
            if (fdCookingTabSelect) {
                fdCookingTabSelect.addEventListener('change', e => {
                    state.fdCooking.recipeBookTab = e.target.value;
                    updateJsonPreview();
                });
            }

            // --- Farmer's Delight: cutting board inputs ---------------------------
            const fdToolRadios = document.querySelectorAll('input[name="fdToolMode"]');
            fdToolRadios.forEach(r => {
                r.addEventListener('change', e => {
                    state.fdCutting.tool.mode = e.target.value;
                    updateJsonPreview();
                });
            });

            const fdToolTagInput = document.getElementById('fdToolTagInput');
            if (fdToolTagInput) {
                fdToolTagInput.addEventListener('input', e => {
                    state.fdCutting.tool.tag = e.target.value;
                    updateJsonPreview();
                });
            }

            const fdToolItemInput = document.getElementById('fdToolItemInput');
            if (fdToolItemInput) {
                fdToolItemInput.addEventListener('input', e => {
                    state.fdCutting.tool.item = e.target.value;
                    updateJsonPreview();
                });
            }

            const fdToolTypeInput = document.getElementById('fdToolTypeInput');
            if (fdToolTypeInput) {
                fdToolTypeInput.addEventListener('input', e => {
                    state.fdCutting.tool.toolType = e.target.value;
                    updateJsonPreview();
                });
            }

            const fdCuttingSoundInput = document.getElementById('fdCuttingSoundInput');
            if (fdCuttingSoundInput) {
                fdCuttingSoundInput.addEventListener('input', e => {
                    state.fdCutting.sound = e.target.value;
                    updateJsonPreview();
                });
            }

            const addFdCuttingResultBtn = document.getElementById('addFdCuttingResultBtn');
            if (addFdCuttingResultBtn) {
                addFdCuttingResultBtn.addEventListener('click', () => {
                    state.fdCutting.results.push({ id: '', count: 1, chance: '' });
                    renderFdCutting();
                    updateJsonPreview();
                });
            }
        }

        // --- Init ----------------------------------------------------------------
        document.addEventListener('DOMContentLoaded', () => {
            buildTypeChips();
            buildGrid('shapedGrid', 'shaped');
            buildGrid('shapelessGrid', 'shapeless');
            bindInputs();
            setupTabs();

            // Default selections for recipes
            selectRecipeType('minecraft:crafting_shaped', 'crafting_shaped', false);
            state.namespace = document.getElementById('nsInput').value;
            state.path = document.getElementById('pathInput').value;
            state.resultItem = document.getElementById('resultItemInput').value;
            state.resultCount = Number(document.getElementById('resultCountInput').value) || 1;
            state.group = document.getElementById('groupInput').value;
            state.category = document.getElementById('categorySelect').value;
            state.showNotification = document.getElementById('showNotificationToggle').checked;

            // Default selections for tags
            state.tags.namespace = document.getElementById('tagNsInput').value;
            state.tags.registry = document.getElementById('tagRegistryInput').value;
            state.tags.path = document.getElementById('tagPathInput').value;
            state.tags.replace = document.getElementById('tagReplaceToggle').checked;
            if (!state.tags.values || state.tags.values.length === 0) {
                state.tags.values = [{ kind: 'item', value: '' }];
            }
            renderTagValues();

            renderCreateProcessing();

            buildMechanicalGrid();

            renderFdCookingIngredients();

            renderFdCutting();

            updateJsonPreview();
            updateTagJsonPreview();
        });
    </script>
</body>

</html>
